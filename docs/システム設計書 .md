# システム設計書 - ソクブツ

## 概要

ソクブツは、自宅サーバー環境での物件新着「有無」監視に特化したシステムです。

### MVP戦略（現在の実装方針）
**軽量Node.js + TypeScript**を基盤とし、Puppeteer-first戦略により25%の安定成功率で実用的な監視を実現します。

**Puppeteer-first戦略の確定仕様（2025年8月17日）:**
- **成功率**: 25.08%（実測値）
- **実行時間**: 平均5.39秒
- **メモリ使用量**: 200-300MB
- **技術**: 3段階アクセスパターン（Bot検知回避 → Google → athome.co.jp）

#### **実装済み機能（2025年8月26日現在）**
- ✅ **PuppeteerScraper**: 3段階アクセスパターン（athome.co.jp対応）
- ✅ **SimpleStorage**: JSON形式データ永続化
- ✅ **MonitoringScheduler**: 5分間隔監視スケジューラー
- ✅ **基盤機能**: logger, telegram, config完備

#### **実装予定機能（今日中）**
- ❌ **PropertyMonitor**: 新着物件検知ロジック
- ❌ **通知統合**: Telegram新着通知機能

### 将来拡張戦略
NestJS + TypeScript重厚スタックへの段階的移行により、Puppeteer-first戦略を基盤とした本格的なシステムを構築します。HTTP-first戦略の限界（Cookie認証では認証突破不可能）が実証されたため、Puppeteer-firstを基盤技術として継続採用します。

### 技術選択の理由
- **MVP**: 軽量性・理解しやすさ・高速起動を重視
- **本格版**: 拡張性・保守性・エンタープライズ機能を重視

## システム全体アーキテクチャ

### 高レベルアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    ソクブツ・システム                        │
├─────────────────────────────────────────────────────────────┤
│  🏠 自宅サーバー環境 (Intel i5-9400T, 7.7GB RAM, WSL2)      │
│                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐  │
│  │   Telegram Bot  │  │   NestJS API    │  │  Scheduler  │  │
│  │   (通知・制御)   │  │   (REST API)    │  │  (定期実行)  │  │
│  └─────────────────┘  └─────────────────┘  └─────────────┘  │
│           │                     │                     │     │
│           └─────────────────────┼─────────────────────┘     │
│                                 │                           │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              スクレイピングエンジン                      │  │
│  │                                                         │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │         Puppeteer-first戦略 (確定仕様)              │  │  │
│  │  │   3段階アクセスパターン | 25%成功率 | 5.4秒実行     │  │  │
│  │  │   Bot検知回避 → Google → athome.co.jp              │  │  │
│  │  │   200-300MB メモリ使用量                            │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                 │                           │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                Bot対策システム                          │  │
│  │                                                         │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │  │
│  │  │ Bot検知回避 │→ │ Google検索  │→ │ 目的サイト      │  │  │
│  │  │ (NestJS)    │  │ (実際実行)  │  │ (セッション継承) │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                 │                           │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                データ管理層                             │  │
│  │                                                         │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │  │
│  │  │ TypeORM +   │  │ File Cache  │  │ Session Store   │  │  │
│  │  │better-sqlite3│  │ (JSON)      │  │ (Memory)        │  │  │
│  │  │ 20-40MB     │  │ 10-20MB     │  │ 10-30MB         │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### データフロー図

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Telegram    │    │ NestJS      │    │ Scheduler   │
│ User Input  │───▶│ API Server  │◀───│ Cron Jobs   │
└─────────────┘    └─────────────┘    └─────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│              スクレイピングエンジン                      │
│                                                         │
│  URL → Puppeteer-first戦略 → 成功/失敗                 │
│   │           │                  │                     │
│   │           ├─ 3段階アクセス ─ 25%成功 ─ 結果        │
│   │           │  (Bot検知→Google→athome)              │
│   │           └─ Stealth Plugin + User-Agent設定       │
│   └─ URL検証・ドメイン制限                              │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                    データ処理                           │
│                                                         │
│  新着判定 → ハッシュ比較 → 結果保存 → 通知判定          │
│     │          │           │          │                │
│     │          │           │          └─ Telegram送信  │
│     │          │           └─ TypeORM保存              │
│     │          └─ SHA-256ハッシュ計算                   │
│     └─ DOM要素抽出・正規化                              │
└─────────────────────────────────────────────────────────┘
```

## 技術スタック詳細

### バックエンド技術

#### NestJS (TypeScript)
**選定理由**:
- RFP要件の完全遵守
- 企業レベルの型安全性
- 依存性注入による高い保守性
- デコレータベースの直感的な開発

**メリット**:
- TypeScriptネイティブサポート
- 豊富なエコシステム
- 自動API文書生成 (Swagger)
- テスタビリティの高さ

**デメリット**:
- Express.jsより若干重い
- 学習コストが高い

#### TypeORM + better-sqlite3
**選定理由**:
- NestJSとの完全統合
- 型安全なクエリビルダー
- マイグレーション管理
- PostgreSQL移行準備

**メリット**:
- エンティティベースの直感的な設計
- 自動スキーマ同期
- リレーション管理の簡素化
- 開発効率の向上

**デメリット**:
- 生SQLより若干のオーバーヘッド
- 複雑なクエリの制約

### フロントエンド技術

#### Telegram Bot API
**選定理由**:
- ユーザーフレンドリーなUI
- プッシュ通知の確実性
- 開発・保守コストの低さ
- クロスプラットフォーム対応

**メリット**:
- 即座の通知配信
- リッチなメッセージ形式
- ユーザー認証の簡素化
- 無料での利用

### スクレイピング技術

#### Puppeteer-first戦略（確定仕様）
**選定理由**:
- アットホーム認証システムの高度化への対応
- HTTP-only戦略の限界（Cookie認証突破不可能）の実証
- 25%の安定成功率で実用的な監視を実現

**実装戦略**:
```
URL → Puppeteer-first（3段階アクセスパターン） → 成功/失敗
      ↓ 25%成功率
      5.4秒実行時間
      200-300MB メモリ使用量
      Bot検知回避 → Google → athome.co.jp
```

#### Puppeteer-first戦略詳細（2025年8月17日実証）

**3段階アクセスパターン**:
```typescript
// ステップ1: Bot検知回避テスト
await page.goto("https://bot.sannysoft.com", {
  waitUntil: 'domcontentloaded',
  timeout: 15000
});
await new Promise(r => setTimeout(r, 2000));

// ステップ2: Google経由でリファラー自然化
await page.goto("https://www.google.com", {
  waitUntil: 'domcontentloaded', 
  timeout: 15000
});
await new Promise(r => setTimeout(r, 2000));

// ステップ3: athome.co.jpへアクセス
await page.goto(url, {
  waitUntil: 'domcontentloaded',
  timeout: 20000
});
```

**実証結果（2025年8月17日）**:
- **成功率**: 25.08%（2117回中531回成功）
- **実行時間**: 平均5.39秒
- **メモリ使用量**: 200-300MB
- **安定性**: 継続的に25%前後を維持

**Stealth Plugin設定**:
```typescript
import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';

const stealth = StealthPlugin();
puppeteer.use(stealth);

const browser = await puppeteer.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox', 
    '--disable-dev-shm-usage',
    '--disable-gpu',
    '--disable-blink-features=AutomationControlled'
  ]
});
```

**確定仕様**:
- **監視範囲**: 最新3件（新着物件の99%をカバー）
- **検知方式**: タイトル+価格+所在地ハッシュ方式
- **監視間隔**: 5分間隔（設定可能）
- **パフォーマンス**: 5.4秒実行、200-300MB使用

#### Bot対策システム
**Google経由アクセスパターン**:
```typescript
// Bot対策シーケンス
1. Bot検知テストサイト訪問
2. Google検索実行
3. 目的サイトへの自然な遷移
4. セッション情報の継承
```

## モジュール設計

### 1. CoreModule (基盤モジュール)
**責務**:
- アプリケーション初期化
- 共通設定管理
- ログ設定
- エラーハンドリング

**主要コンポーネント**:
- ConfigService: 環境変数管理
- LoggerService: 構造化ログ
- ExceptionFilter: 統一エラー処理

### 2. UrlModule (URL管理モジュール)
**責務**:
- 監視URL CRUD操作
- URL検証・正規化
- ユーザー制限管理
- 状態管理

**主要コンポーネント**:
- UrlController: REST API
- UrlService: ビジネスロジック
- UrlEntity: データモデル
- UrlRepository: データアクセス

### 3. ScrapingModule (スクレイピングモジュール)
**責務**:
- 段階的スクレイピング実行
- Bot対策システム
- 新着判定ロジック
- パフォーマンス最適化

**主要コンポーネント**:
- ScrapingService: スクレイピング実行
- BotProtectionService: Bot対策
- ContentAnalyzer: 新着判定
- CacheManager: 結果キャッシュ

### 4. NotificationModule (通知モジュール)
**責務**:
- Telegram Bot統合
- メッセージ送信
- コマンド処理
- ユーザー管理

**主要コンポーネント**:
- TelegramService: Bot API統合
- NotificationService: 通知ロジック
- CommandHandler: コマンド処理
- UserService: ユーザー管理

### モジュール間依存関係

```
CoreModule (基盤)
    ↑
UrlModule ←→ ScrapingModule ←→ NotificationModule
    ↓           ↓                    ↓
TypeORM    CacheManager      Telegram API
```

## セキュリティ設計

### Bot検知回避戦略

#### 1. Google経由アクセスパターン
```typescript
async botProtectionSequence(targetUrl: string) {
  // 1. Bot検知テストサイト
  await page.goto('https://bot.sannysoft.com');
  await page.waitForTimeout(3000);
  
  // 2. Google検索
  await page.goto('https://www.google.com');
  await page.waitForNetworkIdle();
  
  // 3. 目的サイトアクセス
  await page.goto(targetUrl);
  return page;
}
```

#### 2. User-Agentローテーション
- Chrome、Firefox、Safari の実際のUA
- バージョン番号の定期更新
- OS情報の多様化

#### 3. セッション管理
- Cookie情報の継承
- LocalStorage状態の保持
- セッションタイムアウト管理

### アプリケーションセキュリティ

#### 入力値検証
```typescript
@IsUrl()
@IsNotEmpty()
@MaxLength(2048)
url: string;

@IsString()
@Length(1, 100)
name: string;
```

#### レート制限
- IP単位: 60req/min
- ユーザー単位: 100req/hour
- スクレイピング: 5分間隔

#### データ暗号化
- 環境変数の暗号化
- データベース接続文字列の保護
- Telegram Bot Tokenの安全な管理

## パフォーマンス・運用設計

### 並列処理・キャッシュ戦略

#### 並列スクレイピング
```typescript
// 最大3つのURLを並列処理
const results = await Promise.allSettled(
  urls.map(url => this.scrapingService.checkUrl(url))
);
```

#### 多層キャッシュ
1. **メモリキャッシュ**: 頻繁アクセスデータ (5分)
2. **ファイルキャッシュ**: スクレイピング結果 (1時間)
3. **データベースキャッシュ**: 履歴データ (永続)

### ログ・監視システム

#### 構造化ログ
```typescript
logger.info('Scraping completed', {
  urlId: url.id,
  method: 'http-only',
  responseTime: 2500,
  newItemsFound: false,
  memoryUsage: 45
});
```

#### メトリクス収集
- API応答時間
- スクレイピング成功率
- メモリ使用量
- エラー発生率

### ヘルスチェック機能

#### 4つのエンドポイント
1. `/health`: 基本ヘルスチェック
2. `/health/detailed`: 詳細状態
3. `/health/ready`: Kubernetes readiness
4. `/health/live`: Kubernetes liveness

## 拡張性設計

### 水平スケーリング対応

#### ステートレス設計
- セッション情報の外部化
- ファイルキャッシュの共有化
- データベース接続プール

#### ロードバランシング準備
- ヘルスチェック対応
- グレースフルシャットダウン
- セッションアフィニティ不要

### PostgreSQL移行準備

#### マイグレーション戦略
```typescript
// Phase 1: better-sqlite3 (現在)
// Phase 2: PostgreSQL移行
// Phase 3: 読み取り専用レプリカ
```

#### データ移行スクリプト
- スキーマ変換
- データ整合性チェック
- ロールバック機能

### 将来の技術課題

#### マイクロサービス化
- API Gateway導入
- サービス間通信 (gRPC)
- 分散トレーシング

#### 高可用性アーキテクチャ
- 複数インスタンス運用
- データベースレプリケーション
- 障害自動復旧

## 自宅サーバー最適化

### WSL2環境対応

#### メモリ管理
- ガベージコレクション最適化
- メモリリーク監視
- スワップ使用量制限

#### CPU効率化
- 非同期処理の活用
- CPU集約的処理の分散
- アイドル時間の最大化

### リソース監視

#### 閾値設定
- メモリ使用量: 250MB上限
- CPU使用率: 10%平均
- ディスク使用量: 1GB上限

#### アラート機能
- リソース使用量超過
- エラー率上昇
- 応答時間劣化

## 運用・保守

### バックアップ戦略
- データベース: 日次自動バックアップ
- 設定ファイル: Git管理
- ログファイル: 週次ローテーション

### 監視・アラート
- システムメトリクス監視
- エラーログ監視
- 外部サービス死活監視

### 保守作業
- 依存関係の定期更新
- セキュリティパッチ適用
- パフォーマンスチューニング

## Puppeteer-first戦略の詳細仕様

### HTTP-only戦略の限界と戦略転換

#### 検証済み技術的制約
**HTTP-only戦略の限界（実証済み）**:
- **Cookie保存**: ✅ 正常動作（27件保存、認証Cookie含む）
- **Cookie送信**: ✅ 実装済み（HTTPヘッダーで送信）
- **認証突破**: ❌ Cookieのみでは不十分

**技術的制約**:
1. **JavaScriptチャレンジ**: ブラウザ固有のJS実行が必要
2. **TLS フィンガープリンティング**: HTTPクライアントでは模倣困難
3. **動的トークン**: セッション毎の変動トークンが存在
4. **reese84 Cookie**: 高度な暗号化された認証Cookie

### Web Components対応セレクタ

#### athome.co.jp固有のセレクタ戦略
```typescript
const selectors = [
  // Web Components（最優先）
  'athome-csite-pc-part-rent-business-other-bukken-card',
  'athome-search-result-list-item',
  'athome-buy-other-object-list-item',
  'athome-object-item',
  // 従来のセレクタ（フォールバック用）
  '.item-cassette',
  '.p-main-cassette-item',
  '.cassette-item',
  '[class*="bukken-card"]',
  '[class*="property"]'
];
```

#### 物件データ抽出ロジック
```typescript
const properties = await page.evaluate(() => {
  // Web Componentsを含む新しいセレクタでの検索
  for (const selector of selectors) {
    const elements = document.querySelectorAll(selector);
    if (elements.length > 0) {
      // 最初の3件を取得
      const items = Array.from(elements).slice(0, 3).map((el) => {
        const text = el.textContent || '';
        
        // タイトル、価格、所在地を抽出
        let title = el.querySelector('a')?.textContent?.trim() || '';
        let price = text.match(/[0-9,]+万円/)?.[0] || '';
        let location = text.match(/広島[市県][\\s\\S]+?[区町]/)?.[0] || '';
        
        return (title && price) ? { title, price, location } : null;
      }).filter(Boolean);
      
      if (items.length > 0) {
        return items;
      }
    }
  }
  return [];
});
```

### 今後の改善指針

#### 短期施策（成功率25% → 30%）
**User-Agent ローテーション**:
```typescript
const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
];

const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
await page.setUserAgent(randomUA);
```

**待機時間の最適化**:
```typescript
// ランダム化待機（1.5-3秒）
const randomDelay = Math.floor(Math.random() * 1500) + 1500;
await new Promise(r => setTimeout(r, randomDelay));
```

#### パフォーマンス監視
```typescript
interface ScrapingMetrics {
  method: 'puppeteer';
  executionTime: number;
  memoryUsage: number;
  success: boolean;
  url: string;
  timestamp: Date;
}
```

### 戦略転換の意義
**Puppeteer-first戦略**の正式採用により、アットホーム監視システムの実用的な運用を実現。

**主要成果**:
- **成功率**: 15% → 25.08%（66%向上）
- **実行時間**: 平均5.39秒（目標を大幅に上回る高速性）
- **安定性**: 継続的に25%前後を維持
- **スケーラビリティ**: 多URL監視への対応準備完了

HTTP-only戦略の理想を追求したが、athome.co.jpの認証システムの高度化により技術的限界が判明。現実的で安定したPuppeteer-first戦略に転換することで、実用的な監視システムを確立。

## バージョン情報

- **システムバージョン**: 2.0.0
- **戦略**: Puppeteer-first（2025年8月17日確定）
- **NestJS**: 10.x
- **TypeScript**: 5.x
- **Node.js**: 20.x
- **TypeORM**: 0.3.x
- **better-sqlite3**: 9.x
- **Puppeteer**: 23.x
- **puppeteer-extra-plugin-stealth**: 2.x

