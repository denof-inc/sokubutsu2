# スクレイピング戦略ドキュメント

## 概要

ソクブツシステムにおけるPuppeteer-first戦略の詳細仕様と実装ガイドライン。

## 戦略概要（2025年8月17日更新）

### 基本方針
**Puppeteer-first戦略**を正式採用。アットホーム認証システムの高度化により、HTTP-only戦略では限界があることが実証されたため、安定性を重視した戦略に変更。

### 実装戦略
```
URL入力 → Puppeteer (3段階アクセス) → 成功/失敗
          ↓ 25%成功率              
          5-6秒（実測）             
          200-300MB               
```

### **重要な戦略変更（2025年8月17日確定）**
- **HTTP-first戦略の限界**: Cookie認証では認証突破不可能
- **Puppeteer-first戦略採用**: 3段階アクセスパターンで25%安定稼働
- **実証済み効果**: 成功率15% → 25%（66%向上）、実行時間5.4秒

## Puppeteer-first戦略の詳細仕様

### 核心技術: 3段階アクセスパターン

#### 技術スタック
- **ブラウザエンジン**: Puppeteer + Stealth Plugin
- **認証回避**: 3段階アクセスパターン（レインズ実証済み）
- **対象サイト**: 高度な認証システムを持つサイト

#### 性能指標（実測値）
- **成功率**: 25.08%（2117回中531回成功）
- **実行時間**: 5.39秒（平均）
- **メモリ使用量**: 200-300MB
- **安定性**: 継続的に25%前後を維持

#### **3段階アクセスパターン（2025年8月17日実証）**
```typescript
// ステップ1: ボット検出テスト
await page.goto("https://bot.sannysoft.com", {
  waitUntil: 'domcontentloaded',
  timeout: 15000
});
await new Promise(r => setTimeout(r, 2000));

// ステップ2: Google経由でリファラー自然化
await page.goto("https://www.google.com", {
  waitUntil: 'domcontentloaded',
  timeout: 15000
});
await new Promise(r => setTimeout(r, 2000));

// ステップ3: アットホームへアクセス
await page.goto(url, {
  waitUntil: 'domcontentloaded',
  timeout: 20000
});
```

#### Stealth Plugin設定
```typescript
import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';

const stealth = StealthPlugin();
puppeteer.use(stealth);

const browser = await puppeteer.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-gpu', 
    '--disable-blink-features=AutomationControlled',
    '--window-size=1920,1080'
  ]
});

// User-Agent設定
await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36');
await page.setExtraHTTPHeaders({
  "Accept-Language": "ja-JP,ja"
});
```

### Web Components対応セレクタ

#### アットホーム固有のセレクタ
```typescript
const selectors = [
  // Web Components（最優先）
  'athome-csite-pc-part-rent-business-other-bukken-card',
  'athome-search-result-list-item',
  'athome-buy-other-object-list-item', 
  'athome-object-item',
  // 従来のセレクタ（フォールバック用）
  '.item-cassette',
  '.p-main-cassette-item',
  '.cassette-item',
  '[class*="bukken-card"]',
  '[class*="property"]',
  '[class*="bukken"]',
  '[class*="item"]'
];
```

#### 物件データ抽出ロジック
```typescript
const properties = await page.evaluate(() => {
  // Web Componentsを含む新しいセレクタでの検索
  for (const selector of selectors) {
    const elements = document.querySelectorAll(selector);
    if (elements.length > 0) {
      // 最初の3件を取得
      const items = Array.from(elements).slice(0, 3).map((el) => {
        const text = el.textContent || '';
        
        // タイトル、価格、所在地を抽出
        let title = el.querySelector('a')?.textContent?.trim() || '';
        let price = text.match(/[0-9,]+万円/)?.[0] || '';
        let location = text.match(/広島[市県][\\s\\S]+?[区町]/)?.[0] || '';
        
        return (title && price) ? { title, price, location } : null;
      }).filter(Boolean);
      
      if (items.length > 0) {
        return items;
      }
    }
  }
  return [];
});
```

## アットホーム認証システムの技術分析

### HTTP-only戦略の限界（検証済み）

#### 試行結果
- **Cookie保存**: ✅ 正常動作（27件保存、認証Cookie含む）
- **Cookie送信**: ✅ 実装済み（HTTPヘッダーで送信）  
- **認証突破**: ❌ Cookieのみでは不十分

#### 技術的制約
1. **JavaScriptチャレンジ**: ブラウザ固有のJS実行が必要
2. **TLS フィンガープリンティング**: HTTPクライアントでは模倣困難
3. **動的トークン**: セッション毎の変動トークンが存在
4. **reese84 Cookie**: 高度な暗号化された認証Cookie

#### 検証ログ（実際の失敗例）
```
[INFO] scraping.http_fast: Cookie有効 - HTTP-only高速アクセス
[WARN] scraping.auth_detected_http: HTTP-only認証失敗 
→ アットホーム認証ページ【認証中】が継続表示
```

### Puppeteer-first戦略の優位性

#### 実証済み効果
- **成功率改善**: 15% → 25.08%（66%向上）
- **安定性**: 継続的に25%前後を維持
- **実行時間**: 平均5.39秒（目標15-25秒を大幅に上回る）
- **レインズ実績**: 同様パターンで安定稼働実績

## 今後の改善指針

### 短期施策（成功率25% → 30%）

#### User-Agent ローテーション
```typescript
const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'
];

const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];
await page.setUserAgent(randomUA);
```

#### 待機時間の最適化
```typescript
// 現在: 固定2秒待機
await new Promise(r => setTimeout(r, 2000));

// 改善案: 1.5-3秒のランダム化
const randomDelay = Math.floor(Math.random() * 1500) + 1500;
await new Promise(r => setTimeout(r, randomDelay));
```

### 中期施策（成功率30% → 35%）

#### プロキシローテーション検討
```typescript
const proxyList = [
  'http://proxy1:port',
  'http://proxy2:port', 
  'http://proxy3:port'
];

const browser = await puppeteer.launch({
  args: [`--proxy-server=${randomProxy}`]
});
```

#### 認証パターン分析
- 時間帯別成功率の分析
- 週間サイクルでのパターン把握  
- アクセス頻度の最適化

### エラーハンドリング

```typescript
private classifyError(error: string): 'RECOVERABLE' | 'UNRECOVERABLE' | 'BOT_DETECTED' {
  if (error.includes('timeout') || error.includes('network')) {
    return 'RECOVERABLE';
  }
  
  if (error.includes('captcha') || error.includes('/sorry/')) {
    return 'BOT_DETECTED';
  }
  
  return 'UNRECOVERABLE';
}
```

### パフォーマンス監視

```typescript
interface ScrapingMetrics {
  method: 'http' | 'jsdom' | 'playwright';
  executionTime: number;
  memoryUsage: number;
  success: boolean;
  url: string;
  timestamp: Date;
}

async trackPerformance<T>(
  operation: () => Promise<T>,
  method: string,
  url: string
): Promise<{ result: T; metrics: ScrapingMetrics }> {
  const startTime = Date.now();
  const startMemory = process.memoryUsage().heapUsed;
  
  try {
    const result = await operation();
    
    return {
      result,
      metrics: {
        method: method as any,
        executionTime: Date.now() - startTime,
        memoryUsage: process.memoryUsage().heapUsed - startMemory,
        success: true,
        url,
        timestamp: new Date()
      }
    };
  } catch (error) {
    return {
      result: null as T,
      metrics: {
        method: method as any,
        executionTime: Date.now() - startTime,
        memoryUsage: process.memoryUsage().heapUsed - startMemory,
        success: false,
        url,
        timestamp: new Date()
      }
    };
  }
}
```

## 将来拡張

### 新しいサイト対応

```typescript
interface SiteScrapingStrategy {
  siteName: string;
  supportedDomains: string[];
  scrape(url: string, selector?: string): Promise<ScrapingResult>;
  detectSelectors(url: string): Promise<string[]>;
  isSupported(url: string): boolean;
}

// 新しいサイト戦略の実装例
export class NewSiteScrapingStrategy implements SiteScrapingStrategy {
  siteName = '新しいサイト';
  supportedDomains = ['newsite.com'];
  
  async scrape(url: string, selector?: string): Promise<ScrapingResult> {
    // HTTP-first戦略を適用
    return await this.executeHttpFirstStrategy(url, selector);
  }
}
```

### 自動セレクタ検出

```typescript
async detectOptimalSelectors(url: string): Promise<string[]> {
  const response = await axios.get(url);
  const $ = cheerio.load(response.data);
  
  const candidateSelectors = [
    '[class*="property"]',
    '[class*="item"]',
    '[class*="listing"]',
    '[class*="result"]'
  ];
  
  return candidateSelectors.filter(selector => {
    const elements = $(selector);
    return elements.length > 0 && elements.length < 1000; // 適切な要素数
  });
}
```

## 運用・監視

### 成功率監視

```typescript
interface StrategyStats {
  method: string;
  totalAttempts: number;
  successCount: number;
  successRate: number;
  averageExecutionTime: number;
  averageMemoryUsage: number;
}

async getStrategyStatistics(): Promise<StrategyStats[]> {
  // 各戦略の統計情報を収集・分析
}
```

### アラート設定

```typescript
const PERFORMANCE_THRESHOLDS = {
  maxExecutionTime: 30000, // 30秒
  maxMemoryUsage: 300 * 1024 * 1024, // 300MB
  minSuccessRate: 0.8 // 80%
};

async checkPerformanceThresholds(metrics: ScrapingMetrics): Promise<void> {
  if (metrics.executionTime > PERFORMANCE_THRESHOLDS.maxExecutionTime) {
    await this.alertService.sendAlert('実行時間超過', metrics);
  }
  
  if (metrics.memoryUsage > PERFORMANCE_THRESHOLDS.maxMemoryUsage) {
    await this.alertService.sendAlert('メモリ使用量超過', metrics);
  }
}
```

## まとめ

**Puppeteer-first戦略の正式採用により、アットホーム監視システムの実用的な運用を実現。**

### 主要成果
- **成功率**: 15% → 25.08%（66%向上）
- **実行時間**: 平均5.39秒（目標を大幅に上回る高速性）
- **安定性**: 継続的に25%前後を維持
- **スケーラビリティ**: 多URL監視への対応準備完了

### 戦略転換の意義
HTTP-only戦略の理想を追求したが、アットホームの認証システムの高度化により技術的限界が判明。現実的で安定した**Puppeteer-first戦略**に転換することで、実用的な監視システムを確立。

### 運用指針
- **継続監視**: 25%成功率の維持と向上
- **段階的改善**: User-Agentローテーション等による30-35%への向上
- **長期安定性**: レインズでの実績を基にした信頼性の高い運用