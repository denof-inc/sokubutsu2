# ソクブツ品質基準・トラブルシューティング

## 🎯 品質基準・方針

### 品質管理方針
本プロジェクトでは、長期的な保守性と信頼性を重視し、厳格な品質基準を設定します。すべての開発者は以下の基準を遵守し、継続的な品質向上に取り組みます。

### コア品質指標
- **テストカバレッジ**: 80%以上
- **ESLintエラー**: 0件
- **TypeScript警告**: 最小限
- **パフォーマンス**: メモリ300MB以下、実行時間10秒以下
- **可用性**: 95%以上

## 🔧 品質基準詳細

### 1. コード品質基準

#### TypeScript厳格設定
```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

#### ESLint設定
```json
// .eslintrc.json
{
  "extends": [
    "@typescript-eslint/recommended",
    "@typescript-eslint/recommended-requiring-type-checking"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error"
  }
}
```

#### 禁止事項
```typescript
// ❌ 禁止: any型の使用
const data: any = getData();

// ✅ 推奨: 適切な型定義
interface PropertyData {
  title: string;
  price: string;
  location: string;
}
const data: PropertyData = getData();

// ❌ 禁止: 型アサーション濫用
const element = document.getElementById('id') as HTMLElement;

// ✅ 推奨: 型ガード使用
const element = document.getElementById('id');
if (element) {
  // 安全に使用
}
```

### 2. テスト品質基準

#### カバレッジ要件
```bash
# Jest設定
"coverageThreshold": {
  "global": {
    "branches": 80,
    "functions": 80,
    "lines": 80,
    "statements": 80
  }
}
```

#### テストパターン
```typescript
// ✅ 良いテスト例
describe('PropertyScraper', () => {
  describe('scrapeProperties', () => {
    it('正常なHTMLから物件データを抽出する', async () => {
      // Arrange
      const mockHtml = '<div class="property">テスト物件</div>';
      const scraper = new PropertyScraper();
      
      // Act  
      const result = await scraper.scrapeProperties('https://test.com');
      
      // Assert
      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        title: expect.stringContaining('テスト物件')
      });
    });
  });
});
```

### 3. パフォーマンス基準

#### メモリ使用量制限
```typescript
// パフォーマンス監視
const trackMemoryUsage = () => {
  const usage = process.memoryUsage();
  const maxMemory = 300 * 1024 * 1024; // 300MB
  
  if (usage.heapUsed > maxMemory) {
    logger.warn('memory.threshold_exceeded', {
      current: usage.heapUsed,
      limit: maxMemory,
      percentage: (usage.heapUsed / maxMemory) * 100
    });
  }
};
```

#### 実行時間制限
```typescript
// タイムアウト管理
const withTimeout = async <T>(
  promise: Promise<T>, 
  timeoutMs: number
): Promise<T> => {
  const timeoutPromise = new Promise<never>((_, reject) =>
    setTimeout(() => reject(new Error('Timeout exceeded')), timeoutMs)
  );
  
  return Promise.race([promise, timeoutPromise]);
};
```

### 4. ログ・監視基準

#### 構造化ログ
```typescript
// ✅ 推奨: 構造化ログ
logger.info('property.detected', {
  url,
  propertyCount: properties.length,
  executionTime: Date.now() - startTime,
  timestamp: new Date().toISOString()
});

// ❌ 非推奨: 非構造化ログ
console.log('Found ' + properties.length + ' properties');
```

#### エラーログレベル
```typescript
// エラーレベル分類
logger.debug('debug.info', { details }); // 開発時のみ
logger.info('operation.success', { result }); // 正常動作
logger.warn('operation.warning', { issue }); // 注意が必要
logger.error('operation.failed', { error }); // 即座対応必要
```

## 🐛 トラブルシューティングガイド

### 問題分類システム

#### 緊急度分類
- 🔴 **Critical**: システム完全停止（即座対応）
- 🟡 **High**: 機能影響大（24時間以内）
- 🟢 **Medium**: 軽微な影響（1週間以内）
- ⚪ **Low**: 改善事項（定期メンテナンス時）

### 1. システム起動・稼働問題

#### 問題: アプリケーション起動しない
```bash
# 症状確認
npm run start:dev
# Error: Cannot find module 'xyz'

# 診断手順
1. 依存関係確認
npm ls --depth=0
npm audit

2. Node.js/npmバージョン確認
node --version  # 18.0.0以上必要
npm --version   # 9.0.0以上推奨

3. TypeScript設定確認
npx tsc --noEmit

# 解決策
npm ci  # 依存関係再インストール
npm run build  # TypeScriptビルド
```

#### 問題: Docker コンテナ起動失敗
```bash
# 症状確認
docker-compose up
# Error: Container exited with code 1

# 診断手順
1. ログ確認
docker-compose logs sokubutsu

2. コンテナ内確認
docker exec -it sokubutsu-container sh
ps aux
df -h

# 解決策
docker-compose down
docker-compose build --no-cache
docker-compose up -d
```

### 2. スクレイピング問題

#### 問題: Puppeteer タイムアウト
```bash
# 症状
Error: Timeout exceeded after 20000ms

# 診断手順
1. ネットワーク確認
ping google.com
curl -I https://www.athome.co.jp

2. Chrome プロセス確認
ps aux | grep chrome
pgrep chrome

3. メモリ使用量確認
free -h
```

```typescript
// 解決策: タイムアウト調整
const browser = await puppeteer.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-dev-shm-usage',
    '--disable-gpu'
  ],
  timeout: 30000  // 30秒に延長
});
```

### 3. Telegram Webhook問題（疎通不安定の再発防止）

#### 現象
- Botが応答しない／Webhookが外れている／他環境に上書きされた

#### 恒久対策（実装済み）
- Webhook自己修復ガード
  - 定期的に `getWebhookInfo` を検証し、期待URLと不一致なら `setWebhook` を自動実行
  - 設定: `.env(.production)` に `WEBHOOK_GUARDIAN_ENABLED=true`, `WEBHOOK_GUARDIAN_INTERVAL=10`

#### 即時復旧コマンド（安全版）
```bash
# 期待URLにWebHookを再設定（トークン非表示）
docker exec -i sokubutsu-mvp sh -lc '\
  EXP="${ADMIN_PUBLIC_URL%/}/telegram/webhook"; \
  BASE="https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}"; \
  curl -fsS -X POST -d "url=$EXP" "$BASE/setWebhook" | jq'

# Webhookの現在値を確認
curl -fsS "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getWebhookInfo" | jq

# 公開URL（Funnel/Cloudflare）でヘルス確認
curl -I "${ADMIN_PUBLIC_URL%/}/health"
```

#### ベストプラクティス
- dev/prodでBot/Chatを分離（Webhook取り合い防止）
- 起動直後の一時失敗は自己修復ガードに任せる（本番は10分間隔）
- 開発で本番同等を再現する場合は、Tailscale FunnelのURLを `ADMIN_PUBLIC_URL` に設定

#### 問題: Bot検知される
```bash
# 症状
取得ページが認証ページになる

# 診断手順
1. User-Agent確認
curl -H "User-Agent: Mozilla/5.0..." [URL]

2. アクセス間隔確認
# ログで連続アクセス回数を確認
```

```typescript
// 解決策: Stealth plugin強化
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
puppeteer.use(StealthPlugin());

// ランダム待機時間
const randomDelay = Math.floor(Math.random() * 1500) + 1500;
await new Promise(resolve => setTimeout(resolve, randomDelay));
```

### 3. データベース問題

#### 問題: SQLite データベース破損
```bash
# 症状
SQLITE_CORRUPT: database disk image is malformed

# 診断手順
1. ファイル整合性確認
sqlite3 data/database.db "PRAGMA integrity_check;"

2. ディスク容量確認
df -h
ls -la data/

# 解決策
1. バックアップから復旧
cp backups/database_YYYYMMDD.db data/database.db

2. 破損修復試行
sqlite3 data/database.db "VACUUM;"
sqlite3 data/database.db "REINDEX;"
```

#### 問題: データベース接続エラー
```bash
# 症状
Error: ENOENT: no such file or directory

# 診断手順
ls -la data/
echo $DATABASE_PATH

# 解決策
mkdir -p data
npm run typeorm:migration:run
```

### 4. Telegram 通信問題

#### 問題: Bot が応答しない
```bash
# 症状
Telegram メッセージに Bot が反応しない

# 診断手順
1. Bot Token確認
curl https://api.telegram.org/bot${TOKEN}/getMe

2. Webhook確認
curl https://api.telegram.org/bot${TOKEN}/getWebhookInfo

3. ネットワーク確認
curl -I https://api.telegram.org
```

```typescript
// 解決策: Webhook再設定
await bot.telegram.deleteWebhook();
await bot.telegram.setWebhook(WEBHOOK_URL);

// Polling モード切替（デバッグ用）
bot.startPolling();
```

#### 問題: メッセージ送信失敗
```bash
# 症状
Error: 400 Bad Request: can't parse entities

# 診断手順
# HTML形式確認
const message = '<b>テスト</b>';
```

```typescript
// 解決策: HTMLエスケープ
const escapeHtml = (text: string): string => {
  return text.replace(/[<>&]/g, (match) => {
    switch (match) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      default: return match;
    }
  });
};
```

### 5. メモリ・パフォーマンス問題

#### 問題: メモリリーク
```bash
# 症状
RSS memory continuously increasing

# 診断手順
1. メモリ使用量監視
while true; do
  ps aux | grep node
  sleep 5
done

2. Node.js ヒープダンプ取得
kill -USR2 [PID]  # ヒープダンプ生成
```

```typescript
// 解決策: メモリ管理改善
// Puppeteer ページ適切な解放
try {
  const page = await browser.newPage();
  // スクレイピング処理
} finally {
  await page.close();
}

// 大量データ処理の分割
const processInChunks = (data: any[], chunkSize: number = 100) => {
  for (let i = 0; i < data.length; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    processChunk(chunk);
    // ガベージコレクションの機会を与える
    if (i % 1000 === 0) {
      global.gc?.();
    }
  }
};
```

### 6. 設定・環境問題

#### 問題: 環境変数未設定
```bash
# 症状
Error: TELEGRAM_BOT_TOKEN is not defined

# 診断手順
printenv | grep TELEGRAM
cat .env

# 解決策
cp .env.example .env
# 必要な値を設定
nano .env
```

#### 問題: ポート衝突
```bash
# 症状
Error: Port 3000 already in use

# 診断手順
lsof -i :3000
netstat -tulpn | grep :3000

# 解決策
kill -9 [PID]  # プロセス終了
# または別ポート使用
PORT=3001 npm start
```

## 🔍 デバッグツール・技法

### 1. ログ分析

#### ログ検索コマンド
```bash
# エラーログのみ抽出
grep -i error logs/sokubutsu.log

# 時間範囲指定
awk '/2025-08-26 14:00/,/2025-08-26 15:00/' logs/sokubutsu.log

# JSON ログ解析
cat logs/sokubutsu.log | jq '.level == "error"'
```

#### リアルタイム監視
```bash
# ログファイル監視
tail -f logs/sokubutsu.log

# Docker ログ監視
docker-compose logs -f sokubutsu

# システム監視
watch -n 1 'ps aux | grep node'
```

### 2. パフォーマンス分析

#### Node.js プロファイリング
```bash
# CPU プロファイリング
node --prof src/main.js
node --prof-process isolate-0x*.log > profile.txt

# メモリプロファイリング
node --inspect src/main.js
# Chrome DevTools で chrome://inspect
```

#### Docker 監視
```bash
# リソース使用量監視
docker stats

# コンテナ内プロセス確認
docker exec sokubutsu-container top

# ディスク使用量
docker exec sokubutsu-container df -h
```

## 📊 品質チェックリスト

### コミット前チェック
- [ ] ESLint エラー 0件
- [ ] TypeScript コンパイル成功
- [ ] テスト全て通過
- [ ] カバレッジ 80% 以上
- [ ] パフォーマンステスト通過

### デプロイ前チェック
- [ ] 本番ビルド成功
- [ ] Docker イメージビルド成功
- [ ] 環境変数設定確認
- [ ] ヘルスチェック通過
- [ ] ログ出力確認

### 定期メンテナンス
- [ ] 依存関係更新確認
- [ ] セキュリティ脆弱性スキャン
- [ ] ログファイルローテーション
- [ ] バックアップファイル確認
- [ ] パフォーマンス指標レビュー

## 🚨 緊急時対応手順

### サービス完全停止時
1. **状況確認** (5分以内)
   - サービス稼働状況確認
   - エラーログ確認
   - リソース使用量確認

2. **一次対応** (15分以内)
   - サービス再起動試行
   - バックアップからの復旧準備
   - ユーザー通知準備

3. **本格復旧** (30分以内)
   - 根本原因特定
   - 修正実施
   - 動作確認

### 性能劣化時
1. **リソース確認**
   - CPU・メモリ使用率
   - ディスク容量・I/O
   - ネットワーク状況

2. **ボトルネック特定**
   - プロファイリング実行
   - ログ分析
   - データベース性能確認

3. **最適化実施**
   - コード改善
   - リソース調整
   - 設定チューニング

---

**更新日**: 2025年8月26日  
**バージョン**: 2.0（Puppeteer-first対応品質基準）
