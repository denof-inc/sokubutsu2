# テスト戦略・手順書 - 軽量ソクブツ

## 概要

軽量ソクブツは、自宅サーバー環境での物件新着監視に特化したシステムです。このテスト戦略では、軽量アーキテクチャ（メモリ30-60MB、起動時間1-3秒）の特性を活かした効率的なテスト手法を定義し、高品質なソフトウェア開発を支援します。

## テスト戦略

### テストピラミッド

軽量ソクブツでは、効率性と実用性を重視したテストピラミッドを採用します：

```
        E2E Tests (5%)
       ┌─────────────────┐
      │  統合テスト (25%)  │
     └─────────────────────┘
    ┌─────────────────────────┐
   │     単体テスト (70%)      │
  └───────────────────────────┘
```

#### 単体テスト (70%)
- **対象**: 個別の関数・クラス・モジュール
- **実行時間**: 1-5秒
- **頻度**: 開発中の継続実行
- **ツール**: Jest + Node.js標準テスト

#### 統合テスト (25%)
- **対象**: モジュール間の連携・データベース・外部API
- **実行時間**: 10-30秒
- **頻度**: コミット前・CI/CD
- **ツール**: Jest + テストデータベース

#### E2Eテスト (5%)
- **対象**: 完全なワークフロー・ユーザーシナリオ
- **実行時間**: 1-3分
- **頻度**: リリース前・定期実行
- **ツール**: Jest + 実際のTelegram Bot

### テスト原則

#### 1. 軽量性重視
- テスト実行時間の最小化
- メモリ使用量の制限（テスト時100MB以下）
- 並列実行による効率化

#### 2. 実用性重視
- 実際の使用パターンに基づくテスト
- 自宅サーバー環境での動作保証
- Bot対策機能の実証

#### 3. 自動化重視
- CI/CDパイプラインとの統合
- 自動テストレポート生成
- 継続的品質監視

#### 4. 保守性重視
- テストコードの可読性
- テストデータの管理
- テスト環境の一貫性

## 単体テスト

### テスト対象

#### コアサービス
- **ScrapingService**: スクレイピング機能
- **DatabaseService**: データベース操作
- **TelegramService**: Telegram Bot機能
- **MonitoringService**: 監視機能

#### ユーティリティ
- **BotProtection**: Bot対策機能
- **CacheManager**: キャッシュ管理
- **Logger**: ログ機能
- **ConfigManager**: 設定管理

### テスト実装例

#### ScrapingService テスト

```javascript
// tests/unit/services/scraping.test.js
const ScrapingService = require('../../../src/services/scraping');
const nock = require('nock');

describe('ScrapingService', () => {
  let scrapingService;

  beforeEach(() => {
    scrapingService = new ScrapingService();
    nock.cleanAll();
  });

  afterEach(() => {
    nock.cleanAll();
  });

  describe('checkNewListings', () => {
    test('should detect new listings with HTTP-only method', async () => {
      // モックHTTPレスポンス設定
      nock('https://suumo.jp')
        .get('/test-url')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">物件1</div>
              <div class="cassetteitem">物件2</div>
              <div class="cassetteitem">物件3</div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/test-url');

      expect(result).toEqual({
        hasNew: true,
        newCount: 3,
        method: 'http-only',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number),
        botProtection: false
      });
    });

    test('should handle bot protection with Google bypass', async () => {
      // Bot検知シミュレーション
      nock('https://suumo.jp')
        .get('/protected-url')
        .reply(403, 'Access Denied');

      // Google検索モック
      nock('https://www.google.com')
        .get('/search')
        .query(true)
        .reply(200, `
          <html>
            <body>
              <a href="https://suumo.jp/protected-url">物件サイト</a>
            </body>
          </html>
        `);

      // Google経由アクセス成功
      nock('https://suumo.jp')
        .get('/protected-url')
        .matchHeader('referer', /google\.com/)
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">物件1</div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/protected-url', {
        botProtection: true
      });

      expect(result).toEqual({
        hasNew: true,
        newCount: 1,
        method: 'google-bypass',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number),
        botProtection: true
      });
    });

    test('should fallback to JSDOM when HTTP-only fails', async () => {
      // JavaScript必須サイトのシミュレーション
      nock('https://suumo.jp')
        .get('/js-required')
        .reply(200, `
          <html>
            <body>
              <script>
                document.addEventListener('DOMContentLoaded', function() {
                  const container = document.getElementById('listings');
                  container.innerHTML = '<div class="cassetteitem">動的物件1</div>';
                });
              </script>
              <div id="listings"></div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/js-required');

      expect(result.method).toBe('jsdom');
      expect(result.hasNew).toBe(true);
    });

    test('should handle network errors gracefully', async () => {
      nock('https://suumo.jp')
        .get('/network-error')
        .replyWithError('ECONNREFUSED');

      const result = await scrapingService.checkNewListings('https://suumo.jp/network-error');

      expect(result).toEqual({
        hasNew: false,
        newCount: 0,
        method: 'error',
        error: expect.stringContaining('ECONNREFUSED'),
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number)
      });
    });

    test('should respect memory limits', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      nock('https://suumo.jp')
        .get('/large-page')
        .reply(200, 'x'.repeat(1024 * 1024)); // 1MB のレスポンス

      const result = await scrapingService.checkNewListings('https://suumo.jp/large-page');

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

      expect(memoryIncrease).toBeLessThan(10); // 10MB以下の増加
      expect(result.memoryUsage).toBeLessThan(50); // 50MB以下の使用量
    });
  });

  describe('extractListingCount', () => {
    test('should extract listing count from SUUMO HTML', () => {
      const html = `
        <div class="cassetteitem">物件1</div>
        <div class="cassetteitem">物件2</div>
        <div class="cassetteitem">物件3</div>
      `;

      const count = scrapingService.extractListingCount(html, 'suumo.jp');
      expect(count).toBe(3);
    });

    test('should extract listing count from HOMES HTML', () => {
      const html = `
        <div class="bukkenList">
          <div class="bukkenItem">物件1</div>
          <div class="bukkenItem">物件2</div>
        </div>
      `;

      const count = scrapingService.extractListingCount(html, 'homes.co.jp');
      expect(count).toBe(2);
    });

    test('should return 0 for unknown site format', () => {
      const html = '<div>Some content</div>';
      const count = scrapingService.extractListingCount(html, 'unknown-site.com');
      expect(count).toBe(0);
    });
  });
});
```

#### DatabaseService テスト

```javascript
// tests/unit/services/database.test.js
const DatabaseService = require('../../../src/services/database');
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

describe('DatabaseService', () => {
  let databaseService;
  let testDbPath;

  beforeEach(() => {
    testDbPath = path.join(__dirname, '../../fixtures/test.db');
    
    // テスト用データベース作成
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
    
    databaseService = new DatabaseService(testDbPath);
    databaseService.initialize();
  });

  afterEach(() => {
    if (databaseService.db) {
      databaseService.db.close();
    }
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
  });

  describe('URL management', () => {
    test('should create URL successfully', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId: 'test_user_1',
        interval: 300
      };

      const result = await databaseService.createUrl(urlData);

      expect(result).toHaveProperty('id');
      expect(result.url).toBe(urlData.url);
      expect(result.name).toBe(urlData.name);
      expect(result.enabled).toBe(true);
    });

    test('should prevent duplicate URLs for same user', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId: 'test_user_1',
        interval: 300
      };

      await databaseService.createUrl(urlData);

      await expect(databaseService.createUrl(urlData))
        .rejects.toThrow('URL already exists for this user');
    });

    test('should enforce URL limit per user', async () => {
      const userId = 'test_user_1';
      
      // ユーザーのURL制限を2に設定
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 2
      });

      // 2つのURL作成（成功）
      await databaseService.createUrl({
        url: 'https://suumo.jp/test1',
        name: 'テスト物件1',
        userId,
        interval: 300
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/test2',
        name: 'テスト物件2',
        userId,
        interval: 300
      });

      // 3つ目のURL作成（失敗）
      await expect(databaseService.createUrl({
        url: 'https://suumo.jp/test3',
        name: 'テスト物件3',
        userId,
        interval: 300
      })).rejects.toThrow('URL limit exceeded');
    });

    test('should get active URLs for monitoring', async () => {
      const userId = 'test_user_1';

      // アクティブなURL
      await databaseService.createUrl({
        url: 'https://suumo.jp/active',
        name: 'アクティブ物件',
        userId,
        enabled: true
      });

      // 無効なURL
      await databaseService.createUrl({
        url: 'https://suumo.jp/inactive',
        name: '無効物件',
        userId,
        enabled: false
      });

      const activeUrls = await databaseService.getActiveUrls();

      expect(activeUrls).toHaveLength(1);
      expect(activeUrls[0].url).toBe('https://suumo.jp/active');
    });
  });

  describe('Monitoring logs', () => {
    test('should save monitoring log', async () => {
      const urlId = 'test_url_1';
      const logData = {
        urlId,
        newCount: 5,
        hasNew: true,
        method: 'http-only',
        responseTime: 1500,
        memoryUsage: 25.5,
        botProtection: false
      };

      const result = await databaseService.saveMonitoringLog(logData);

      expect(result).toHaveProperty('id');
      expect(result.newCount).toBe(5);
      expect(result.hasNew).toBe(true);
      expect(result.method).toBe('http-only');
    });

    test('should get recent monitoring logs', async () => {
      const urlId = 'test_url_1';

      // 複数のログを作成
      for (let i = 0; i < 5; i++) {
        await databaseService.saveMonitoringLog({
          urlId,
          newCount: i,
          hasNew: i > 0,
          method: 'http-only',
          responseTime: 1000 + i * 100
        });
      }

      const recentLogs = await databaseService.getRecentLogs(urlId, 3);

      expect(recentLogs).toHaveLength(3);
      expect(recentLogs[0].newCount).toBe(4); // 最新が最初
      expect(recentLogs[2].newCount).toBe(2);
    });

    test('should calculate monitoring statistics', async () => {
      const urlId = 'test_url_1';

      // テストデータ作成
      const testData = [
        { newCount: 0, hasNew: false, responseTime: 1000, method: 'http-only' },
        { newCount: 3, hasNew: true, responseTime: 1500, method: 'http-only' },
        { newCount: 0, hasNew: false, responseTime: 800, method: 'http-only' },
        { newCount: 2, hasNew: true, responseTime: 1200, method: 'jsdom' },
        { newCount: 1, hasNew: true, responseTime: 2000, method: 'jsdom' }
      ];

      for (const data of testData) {
        await databaseService.saveMonitoringLog({ urlId, ...data });
      }

      const stats = await databaseService.getMonitoringStats(urlId);

      expect(stats).toEqual({
        totalChecks: 5,
        newDetections: 3,
        detectionRate: 0.6,
        avgResponseTime: 1300,
        methodDistribution: {
          'http-only': 3,
          'jsdom': 2
        },
        avgNewCount: 1.2
      });
    });
  });

  describe('Performance', () => {
    test('should handle large dataset efficiently', async () => {
      const startTime = Date.now();
      const urlId = 'test_url_1';

      // 1000件のログを挿入
      const insertPromises = [];
      for (let i = 0; i < 1000; i++) {
        insertPromises.push(databaseService.saveMonitoringLog({
          urlId,
          newCount: Math.floor(Math.random() * 10),
          hasNew: Math.random() > 0.5,
          method: 'http-only',
          responseTime: 1000 + Math.random() * 1000
        }));
      }

      await Promise.all(insertPromises);

      const insertTime = Date.now() - startTime;
      expect(insertTime).toBeLessThan(5000); // 5秒以内

      // クエリ性能テスト
      const queryStartTime = Date.now();
      const recentLogs = await databaseService.getRecentLogs(urlId, 100);
      const queryTime = Date.now() - queryStartTime;

      expect(recentLogs).toHaveLength(100);
      expect(queryTime).toBeLessThan(100); // 100ms以内
    });

    test('should maintain memory usage under limits', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      // 大量のデータ操作
      for (let i = 0; i < 100; i++) {
        await databaseService.saveMonitoringLog({
          urlId: `test_url_${i}`,
          newCount: i,
          hasNew: true,
          method: 'http-only',
          responseTime: 1000
        });
      }

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

      expect(memoryIncrease).toBeLessThan(20); // 20MB以下の増加
    });
  });
});
```

#### TelegramService テスト

```javascript
// tests/unit/services/telegram.test.js
const TelegramService = require('../../../src/services/telegram');
const nock = require('nock');

describe('TelegramService', () => {
  let telegramService;
  const mockBotToken = 'test_bot_token';

  beforeEach(() => {
    telegramService = new TelegramService(mockBotToken);
    nock.cleanAll();
  });

  afterEach(() => {
    nock.cleanAll();
  });

  describe('sendMessage', () => {
    test('should send message successfully', async () => {
      const chatId = 'test_chat_id';
      const message = 'テストメッセージ';

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, {
          ok: true,
          result: {
            message_id: 123,
            chat: { id: chatId },
            text: message
          }
        });

      const result = await telegramService.sendMessage(chatId, message);

      expect(result).toEqual({
        success: true,
        messageId: 123
      });
    });

    test('should handle rate limiting', async () => {
      const chatId = 'test_chat_id';
      const message = 'テストメッセージ';

      // 最初のリクエストでレート制限
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(429, {
          ok: false,
          error_code: 429,
          description: 'Too Many Requests: retry after 1'
        });

      // 2回目のリクエストで成功
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, {
          ok: true,
          result: { message_id: 123 }
        });

      const result = await telegramService.sendMessage(chatId, message);

      expect(result.success).toBe(true);
    });

    test('should split long messages', async () => {
      const chatId = 'test_chat_id';
      const longMessage = 'x'.repeat(5000); // 4096文字制限を超える

      // 2つのメッセージに分割されることを期待
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .times(2)
        .reply(200, {
          ok: true,
          result: { message_id: 123 }
        });

      const result = await telegramService.sendMessage(chatId, longMessage);

      expect(result.success).toBe(true);
      expect(result.messageCount).toBe(2);
    });
  });

  describe('processCommand', () => {
    test('should handle /start command', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id', username: 'testuser' },
        text: '/start'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('start');
      expect(result.success).toBe(true);
    });

    test('should handle /add command with URL', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id' },
        text: '/add https://suumo.jp/test 渋谷1K'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('add');
      expect(result.params).toEqual({
        url: 'https://suumo.jp/test',
        name: '渋谷1K'
      });
    });

    test('should handle invalid commands gracefully', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id' },
        text: '/invalid_command'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('unknown');
      expect(result.success).toBe(true);
    });
  });

  describe('formatNotification', () => {
    test('should format new listing notification', () => {
      const data = {
        urlName: '渋谷1K物件',
        newCount: 3,
        totalChecked: 150,
        url: 'https://suumo.jp/test',
        method: 'http-only',
        responseTime: 1500
      };

      const formatted = telegramService.formatNotification('new_listings', data);

      expect(formatted).toContain('🏠 新着物件発見！');
      expect(formatted).toContain('渋谷1K物件');
      expect(formatted).toContain('3件の新着');
      expect(formatted).toContain('https://suumo.jp/test');
    });

    test('should format hourly summary notification', () => {
      const data = {
        urlName: '渋谷1K物件',
        checksCount: 12,
        newDetections: 2,
        avgResponseTime: 1200,
        method: 'http-only'
      };

      const formatted = telegramService.formatNotification('hourly_summary', data);

      expect(formatted).toContain('📊 1時間サマリー');
      expect(formatted).toContain('渋谷1K物件');
      expect(formatted).toContain('12回チェック');
      expect(formatted).toContain('2回新着検出');
    });
  });
});
```

### テスト実行

#### 基本実行

```bash
# 全単体テスト実行
pnpm test:unit

# 特定のテストファイル
pnpm test tests/unit/services/scraping.test.js

# 特定のテストケース
pnpm test --testNamePattern="should detect new listings"

# 監視モード（開発時）
pnpm test:unit --watch
```

#### カバレッジ測定

```bash
# カバレッジ付きテスト実行
pnpm test:unit --coverage

# カバレッジレポート確認
open coverage/lcov-report/index.html

# カバレッジ閾値設定（jest.config.js）
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

## 統合テスト

### テスト対象

#### API統合テスト
- REST APIエンドポイント
- リクエスト/レスポンス形式
- エラーハンドリング
- 認証・認可

#### データベース統合テスト
- CRUD操作の連携
- トランザクション処理
- データ整合性
- パフォーマンス

#### 外部サービス統合テスト
- Telegram API連携
- スクレイピング対象サイト
- Bot対策機能
- ネットワーク処理

### テスト実装例

#### API統合テスト

```javascript
// tests/integration/api.test.js
const request = require('supertest');
const app = require('../../src/app');
const DatabaseService = require('../../src/services/database');

describe('API Integration Tests', () => {
  let databaseService;

  beforeAll(async () => {
    // テスト用データベース初期化
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();
    
    // アプリケーションにテストデータベース設定
    app.set('database', databaseService);
  });

  afterAll(async () => {
    if (databaseService.db) {
      databaseService.db.close();
    }
  });

  beforeEach(async () => {
    // テストデータクリア
    await databaseService.clearAllData();
  });

  describe('GET /health', () => {
    test('should return health status', async () => {
      const response = await request(app)
        .get('/health')
        .expect(200);

      expect(response.body).toEqual({
        status: 'ok',
        timestamp: expect.any(String),
        uptime: expect.any(Number),
        memory: {
          used: expect.any(Number),
          total: expect.any(Number)
        },
        database: 'connected'
      });
    });

    test('should return detailed health status', async () => {
      const response = await request(app)
        .get('/health/detailed')
        .expect(200);

      expect(response.body).toHaveProperty('status', 'ok');
      expect(response.body).toHaveProperty('services');
      expect(response.body.services).toHaveProperty('database');
      expect(response.body.services).toHaveProperty('scraping');
      expect(response.body.services).toHaveProperty('telegram');
    });
  });

  describe('POST /api/urls', () => {
    test('should create URL successfully', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId: 'test_user_1',
        interval: 300
      };

      const response = await request(app)
        .post('/api/urls')
        .send(urlData)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.url).toBe(urlData.url);
      expect(response.body.name).toBe(urlData.name);
      expect(response.body.enabled).toBe(true);
    });

    test('should validate URL format', async () => {
      const invalidUrlData = {
        url: 'invalid-url',
        name: 'テスト物件',
        userId: 'test_user_1'
      };

      const response = await request(app)
        .post('/api/urls')
        .send(invalidUrlData)
        .expect(400);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Invalid URL format');
    });

    test('should enforce URL limit', async () => {
      const userId = 'test_user_1';

      // ユーザー作成（URL制限2）
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 2
      });

      // 2つのURL作成（成功）
      for (let i = 1; i <= 2; i++) {
        await request(app)
          .post('/api/urls')
          .send({
            url: `https://suumo.jp/test${i}`,
            name: `テスト物件${i}`,
            userId,
            interval: 300
          })
          .expect(201);
      }

      // 3つ目のURL作成（失敗）
      const response = await request(app)
        .post('/api/urls')
        .send({
          url: 'https://suumo.jp/test3',
          name: 'テスト物件3',
          userId,
          interval: 300
        })
        .expect(400);

      expect(response.body.error).toContain('URL limit exceeded');
    });
  });

  describe('GET /api/urls/:userId', () => {
    test('should get user URLs', async () => {
      const userId = 'test_user_1';

      // テストデータ作成
      await databaseService.createUrl({
        url: 'https://suumo.jp/test1',
        name: 'テスト物件1',
        userId,
        enabled: true
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/test2',
        name: 'テスト物件2',
        userId,
        enabled: false
      });

      const response = await request(app)
        .get(`/api/urls/${userId}`)
        .expect(200);

      expect(response.body).toHaveLength(2);
      expect(response.body[0]).toHaveProperty('url');
      expect(response.body[0]).toHaveProperty('name');
      expect(response.body[0]).toHaveProperty('enabled');
    });

    test('should filter by enabled status', async () => {
      const userId = 'test_user_1';

      // テストデータ作成
      await databaseService.createUrl({
        url: 'https://suumo.jp/active',
        name: 'アクティブ物件',
        userId,
        enabled: true
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/inactive',
        name: '無効物件',
        userId,
        enabled: false
      });

      const response = await request(app)
        .get(`/api/urls/${userId}?enabled=true`)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].enabled).toBe(true);
    });
  });

  describe('PUT /api/urls/:id', () => {
    test('should update URL successfully', async () => {
      // URL作成
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: '元の名前',
        userId: 'test_user_1',
        interval: 300
      });

      const updateData = {
        name: '更新された名前',
        interval: 600,
        enabled: false
      };

      const response = await request(app)
        .put(`/api/urls/${url.id}`)
        .send(updateData)
        .expect(200);

      expect(response.body.name).toBe('更新された名前');
      expect(response.body.interval).toBe(600);
      expect(response.body.enabled).toBe(false);
    });

    test('should return 404 for non-existent URL', async () => {
      const response = await request(app)
        .put('/api/urls/non-existent-id')
        .send({ name: '更新' })
        .expect(404);

      expect(response.body.error).toContain('URL not found');
    });
  });

  describe('DELETE /api/urls/:id', () => {
    test('should delete URL successfully', async () => {
      // URL作成
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId: 'test_user_1'
      });

      await request(app)
        .delete(`/api/urls/${url.id}`)
        .expect(204);

      // 削除確認
      const urls = await databaseService.getUserUrls('test_user_1');
      expect(urls).toHaveLength(0);
    });
  });

  describe('GET /api/monitoring/:urlId/logs', () => {
    test('should get monitoring logs', async () => {
      const urlId = 'test_url_1';

      // テストログ作成
      for (let i = 0; i < 5; i++) {
        await databaseService.saveMonitoringLog({
          urlId,
          newCount: i,
          hasNew: i > 0,
          method: 'http-only',
          responseTime: 1000 + i * 100
        });
      }

      const response = await request(app)
        .get(`/api/monitoring/${urlId}/logs?limit=3`)
        .expect(200);

      expect(response.body).toHaveLength(3);
      expect(response.body[0].newCount).toBe(4); // 最新が最初
    });

    test('should get monitoring statistics', async () => {
      const urlId = 'test_url_1';

      // テストログ作成
      await databaseService.saveMonitoringLog({
        urlId,
        newCount: 3,
        hasNew: true,
        method: 'http-only',
        responseTime: 1500
      });

      await databaseService.saveMonitoringLog({
        urlId,
        newCount: 0,
        hasNew: false,
        method: 'http-only',
        responseTime: 1000
      });

      const response = await request(app)
        .get(`/api/monitoring/${urlId}/stats`)
        .expect(200);

      expect(response.body).toEqual({
        totalChecks: 2,
        newDetections: 1,
        detectionRate: 0.5,
        avgResponseTime: 1250,
        methodDistribution: {
          'http-only': 2
        },
        avgNewCount: 1.5
      });
    });
  });
});
```

#### データベース統合テスト

```javascript
// tests/integration/database.test.js
const DatabaseService = require('../../src/services/database');
const path = require('path');
const fs = require('fs');

describe('Database Integration Tests', () => {
  let databaseService;
  let testDbPath;

  beforeAll(() => {
    testDbPath = path.join(__dirname, '../fixtures/integration_test.db');
  });

  beforeEach(async () => {
    // テスト用データベース作成
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
    
    databaseService = new DatabaseService(testDbPath);
    await databaseService.initialize();
  });

  afterEach(async () => {
    if (databaseService.db) {
      databaseService.db.close();
    }
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
  });

  describe('Transaction handling', () => {
    test('should rollback on error', async () => {
      const userId = 'test_user_1';

      try {
        await databaseService.db.transaction(() => {
          // ユーザー作成
          databaseService.createUser({
            id: userId,
            username: 'testuser'
          });

          // 意図的にエラーを発生
          throw new Error('Test error');
        })();
      } catch (error) {
        // エラーは期待される
      }

      // ユーザーが作成されていないことを確認
      const user = await databaseService.getUser(userId);
      expect(user).toBeNull();
    });

    test('should commit on success', async () => {
      const userId = 'test_user_1';

      await databaseService.db.transaction(() => {
        databaseService.createUser({
          id: userId,
          username: 'testuser'
        });

        databaseService.createUrl({
          url: 'https://suumo.jp/test',
          name: 'テスト物件',
          userId
        });
      })();

      // データが正常に保存されていることを確認
      const user = await databaseService.getUser(userId);
      const urls = await databaseService.getUserUrls(userId);

      expect(user).not.toBeNull();
      expect(urls).toHaveLength(1);
    });
  });

  describe('Concurrent access', () => {
    test('should handle concurrent URL creation', async () => {
      const userId = 'test_user_1';

      // ユーザー作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 5
      });

      // 並行してURL作成
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(
          databaseService.createUrl({
            url: `https://suumo.jp/test${i}`,
            name: `テスト物件${i}`,
            userId
          })
        );
      }

      const results = await Promise.all(promises);

      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toHaveProperty('id');
      });

      // データベースに正しく保存されていることを確認
      const urls = await databaseService.getUserUrls(userId);
      expect(urls).toHaveLength(3);
    });

    test('should handle concurrent monitoring log creation', async () => {
      const urlId = 'test_url_1';

      // 並行してログ作成
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(
          databaseService.saveMonitoringLog({
            urlId,
            newCount: i,
            hasNew: i % 2 === 0,
            method: 'http-only',
            responseTime: 1000 + i * 100
          })
        );
      }

      const results = await Promise.all(promises);

      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result).toHaveProperty('id');
      });

      // データベースに正しく保存されていることを確認
      const logs = await databaseService.getRecentLogs(urlId, 20);
      expect(logs).toHaveLength(10);
    });
  });

  describe('Data integrity', () => {
    test('should maintain foreign key constraints', async () => {
      const userId = 'test_user_1';
      const urlId = 'test_url_1';

      // ユーザーを作成せずにURLを作成しようとする
      await expect(
        databaseService.createUrl({
          url: 'https://suumo.jp/test',
          name: 'テスト物件',
          userId: 'non_existent_user'
        })
      ).rejects.toThrow();

      // ユーザー作成後にURL作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId
      });

      // URLを削除せずにユーザーを削除しようとする
      await expect(
        databaseService.deleteUser(userId)
      ).rejects.toThrow();

      // URL削除後にユーザー削除
      await databaseService.deleteUrl(url.id);
      await databaseService.deleteUser(userId);

      // 削除確認
      const user = await databaseService.getUser(userId);
      expect(user).toBeNull();
    });

    test('should cascade delete properly', async () => {
      const userId = 'test_user_1';

      // ユーザーとURL作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'テスト物件',
        userId
      });

      // 監視ログ作成
      await databaseService.saveMonitoringLog({
        urlId: url.id,
        newCount: 3,
        hasNew: true,
        method: 'http-only'
      });

      // URL削除（カスケード削除）
      await databaseService.deleteUrl(url.id);

      // 関連する監視ログも削除されていることを確認
      const logs = await databaseService.getRecentLogs(url.id, 10);
      expect(logs).toHaveLength(0);
    });
  });

  describe('Performance under load', () => {
    test('should handle large dataset efficiently', async () => {
      const startTime = Date.now();

      // 大量のデータ作成
      const userPromises = [];
      for (let i = 0; i < 100; i++) {
        userPromises.push(
          databaseService.createUser({
            id: `user_${i}`,
            username: `user${i}`
          })
        );
      }
      await Promise.all(userPromises);

      const urlPromises = [];
      for (let i = 0; i < 500; i++) {
        urlPromises.push(
          databaseService.createUrl({
            url: `https://suumo.jp/test${i}`,
            name: `テスト物件${i}`,
            userId: `user_${i % 100}`
          })
        );
      }
      await Promise.all(urlPromises);

      const setupTime = Date.now() - startTime;
      expect(setupTime).toBeLessThan(10000); // 10秒以内

      // クエリ性能テスト
      const queryStartTime = Date.now();
      const activeUrls = await databaseService.getActiveUrls();
      const queryTime = Date.now() - queryStartTime;

      expect(activeUrls).toHaveLength(500);
      expect(queryTime).toBeLessThan(500); // 500ms以内
    });
  });
});
```

### テスト実行

```bash
# 統合テスト実行
pnpm test:integration

# 特定の統合テスト
pnpm test tests/integration/api.test.js

# 統合テスト + カバレッジ
pnpm test:integration --coverage
```

## E2Eテスト

### テスト対象

#### 完全ワークフロー
- ユーザー登録からURL監視まで
- 新着検出から通知送信まで
- エラー発生から復旧まで

#### ユーザーシナリオ
- Telegram Botでの操作
- 複数URL管理
- 通知設定変更

### テスト実装例

```javascript
// tests/e2e/full-workflow.test.js
const TelegramBot = require('node-telegram-bot-api');
const DatabaseService = require('../../src/services/database');
const ScrapingService = require('../../src/services/scraping');
const MonitoringService = require('../../src/services/monitoring');
const nock = require('nock');

describe('E2E Full Workflow Tests', () => {
  let databaseService;
  let scrapingService;
  let monitoringService;
  let mockBot;

  beforeAll(async () => {
    // テスト環境初期化
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();

    scrapingService = new ScrapingService();
    monitoringService = new MonitoringService(databaseService, scrapingService);

    // Telegram Bot モック
    mockBot = {
      sendMessage: jest.fn().mockResolvedValue({ message_id: 123 }),
      on: jest.fn()
    };
  });

  beforeEach(() => {
    nock.cleanAll();
    jest.clearAllMocks();
  });

  describe('Complete user journey', () => {
    test('should complete full workflow from registration to notification', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // 1. ユーザー登録
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      // 2. URL追加
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test-property',
        name: '渋谷1K物件',
        userId,
        interval: 300
      });

      // 3. スクレイピング結果モック（新着あり）
      nock('https://suumo.jp')
        .get('/test-property')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">物件1</div>
              <div class="cassetteitem">物件2</div>
              <div class="cassetteitem">物件3</div>
            </body>
          </html>
        `);

      // 4. 監視実行
      const monitoringResult = await monitoringService.checkUrl(url.id);

      // 5. 結果検証
      expect(monitoringResult).toEqual({
        urlId: url.id,
        hasNew: true,
        newCount: 3,
        method: 'http-only',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number)
      });

      // 6. 通知送信確認
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('🏠 新着物件発見！')
      );

      // 7. データベース記録確認
      const logs = await databaseService.getRecentLogs(url.id, 1);
      expect(logs).toHaveLength(1);
      expect(logs[0].hasNew).toBe(true);
      expect(logs[0].newCount).toBe(3);
    });

    test('should handle bot protection workflow', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ユーザーとURL作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/protected-property',
        name: 'Bot対策物件',
        userId,
        interval: 300
      });

      // Bot検知シミュレーション
      nock('https://suumo.jp')
        .get('/protected-property')
        .reply(403, 'Access Denied');

      // Google検索モック
      nock('https://www.google.com')
        .get('/search')
        .query(true)
        .reply(200, `
          <html>
            <body>
              <a href="https://suumo.jp/protected-property">物件サイト</a>
            </body>
          </html>
        `);

      // Google経由アクセス成功
      nock('https://suumo.jp')
        .get('/protected-property')
        .matchHeader('referer', /google\.com/)
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">保護された物件1</div>
              <div class="cassetteitem">保護された物件2</div>
            </body>
          </html>
        `);

      // 監視実行
      const monitoringResult = await monitoringService.checkUrl(url.id);

      // Bot対策が機能していることを確認
      expect(monitoringResult.method).toBe('google-bypass');
      expect(monitoringResult.botProtection).toBe(true);
      expect(monitoringResult.hasNew).toBe(true);
      expect(monitoringResult.newCount).toBe(2);

      // 通知送信確認
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('🛡️ Bot対策を適用して新着物件を発見')
      );
    });

    test('should handle error recovery workflow', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ユーザーとURL作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/error-property',
        name: 'エラー物件',
        userId,
        interval: 300
      });

      // 1回目: ネットワークエラー
      nock('https://suumo.jp')
        .get('/error-property')
        .replyWithError('ECONNREFUSED');

      let monitoringResult = await monitoringService.checkUrl(url.id);

      expect(monitoringResult.method).toBe('error');
      expect(monitoringResult.hasNew).toBe(false);
      expect(monitoringResult.error).toContain('ECONNREFUSED');

      // エラー通知確認
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('⚠️ 監視エラー')
      );

      // 2回目: 復旧成功
      nock('https://suumo.jp')
        .get('/error-property')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">復旧後物件1</div>
            </body>
          </html>
        `);

      monitoringResult = await monitoringService.checkUrl(url.id);

      expect(monitoringResult.method).toBe('http-only');
      expect(monitoringResult.hasNew).toBe(true);
      expect(monitoringResult.newCount).toBe(1);

      // 復旧通知確認
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('✅ 監視復旧')
      );
    });
  });

  describe('Multiple URL management', () => {
    test('should handle multiple URLs for single user', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ユーザー作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId,
        urlLimit: 3
      });

      // 複数URL作成
      const urls = [];
      for (let i = 1; i <= 3; i++) {
        const url = await databaseService.createUrl({
          url: `https://suumo.jp/property${i}`,
          name: `物件${i}`,
          userId,
          interval: 300
        });
        urls.push(url);

        // 各URLのレスポンスモック
        nock('https://suumo.jp')
          .get(`/property${i}`)
          .reply(200, `
            <html>
              <body>
                ${Array.from({length: i}, (_, j) => `<div class="cassetteitem">物件${i}-${j+1}</div>`).join('')}
              </body>
            </html>
          `);
      }

      // 全URL監視実行
      const results = await Promise.all(
        urls.map(url => monitoringService.checkUrl(url.id))
      );

      // 結果検証
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result.hasNew).toBe(true);
        expect(result.newCount).toBe(index + 1);
      });

      // 通知送信確認（各URLごと）
      expect(mockBot.sendMessage).toHaveBeenCalledTimes(3);
    });

    test('should handle URL enable/disable workflow', async () => {
      const userId = 'test_user_1';

      // ユーザーとURL作成
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/toggle-property',
        name: 'トグル物件',
        userId,
        enabled: true
      });

      // 有効状態での監視
      nock('https://suumo.jp')
        .get('/toggle-property')
        .reply(200, '<div class="cassetteitem">物件1</div>');

      let activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(1);

      let result = await monitoringService.checkUrl(url.id);
      expect(result.hasNew).toBe(true);

      // URL無効化
      await databaseService.updateUrl(url.id, { enabled: false });

      activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(0);

      // 無効状態では監視されない
      const disabledResult = await monitoringService.checkUrl(url.id);
      expect(disabledResult).toBeNull();

      // URL再有効化
      await databaseService.updateUrl(url.id, { enabled: true });

      activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(1);
    });
  });

  describe('Performance under realistic load', () => {
    test('should handle realistic monitoring load', async () => {
      const userCount = 10;
      const urlsPerUser = 3;
      const totalUrls = userCount * urlsPerUser;

      // ユーザーとURL作成
      const users = [];
      const urls = [];

      for (let i = 1; i <= userCount; i++) {
        const user = await databaseService.createUser({
          id: `user_${i}`,
          username: `user${i}`,
          chatId: `chat_${i}`,
          urlLimit: urlsPerUser
        });
        users.push(user);

        for (let j = 1; j <= urlsPerUser; j++) {
          const url = await databaseService.createUrl({
            url: `https://suumo.jp/user${i}_property${j}`,
            name: `ユーザー${i}物件${j}`,
            userId: user.id,
            interval: 300
          });
          urls.push(url);

          // レスポンスモック
          nock('https://suumo.jp')
            .get(`/user${i}_property${j}`)
            .reply(200, `
              <html>
                <body>
                  ${Array.from({length: j}, (_, k) => `<div class="cassetteitem">物件${i}-${j}-${k+1}</div>`).join('')}
                </body>
              </html>
            `);
        }
      }

      // 全URL並行監視
      const startTime = Date.now();
      const results = await Promise.all(
        urls.map(url => monitoringService.checkUrl(url.id))
      );
      const totalTime = Date.now() - startTime;

      // パフォーマンス検証
      expect(results).toHaveLength(totalUrls);
      expect(totalTime).toBeLessThan(30000); // 30秒以内

      // 全て成功していることを確認
      results.forEach(result => {
        expect(result.hasNew).toBe(true);
        expect(result.method).toBe('http-only');
      });

      // メモリ使用量確認
      const memoryUsage = process.memoryUsage();
      expect(memoryUsage.heapUsed / 1024 / 1024).toBeLessThan(100); // 100MB以下
    });
  });
});
```

### テスト実行

```bash
# E2Eテスト実行
pnpm test:e2e

# タイムアウト延長
pnpm test:e2e --testTimeout=60000

# E2Eテスト + 詳細ログ
pnpm test:e2e --verbose
```

## パフォーマンステスト

### 負荷テスト

#### メモリ使用量テスト

```javascript
// tests/performance/memory.test.js
const ScrapingService = require('../../src/services/scraping');
const DatabaseService = require('../../src/services/database');

describe('Memory Performance Tests', () => {
  let scrapingService;
  let databaseService;

  beforeAll(() => {
    scrapingService = new ScrapingService();
    databaseService = new DatabaseService(':memory:');
  });

  test('should maintain memory usage under 60MB during scraping', async () => {
    const initialMemory = process.memoryUsage().heapUsed;

    // 大量のスクレイピング実行
    const promises = [];
    for (let i = 0; i < 50; i++) {
      promises.push(
        scrapingService.checkNewListings(`https://example.com/page${i}`)
      );
    }

    await Promise.allSettled(promises);

    // ガベージコレクション強制実行
    if (global.gc) {
      global.gc();
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

    expect(memoryIncrease).toBeLessThan(30); // 30MB以下の増加
    expect(finalMemory / 1024 / 1024).toBeLessThan(60); // 総使用量60MB以下
  });

  test('should handle memory pressure gracefully', async () => {
    // メモリ制限シミュレーション
    const originalMaxOldSpaceSize = process.env.NODE_OPTIONS;
    process.env.NODE_OPTIONS = '--max-old-space-size=128'; // 128MB制限

    try {
      // メモリ集約的な処理
      const largeData = [];
      for (let i = 0; i < 100; i++) {
        largeData.push(await scrapingService.checkNewListings('https://example.com/large'));
      }

      // メモリ不足でクラッシュしないことを確認
      expect(largeData).toHaveLength(100);
    } finally {
      process.env.NODE_OPTIONS = originalMaxOldSpaceSize;
    }
  });
});
```

#### レスポンス時間テスト

```javascript
// tests/performance/response-time.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Response Time Performance Tests', () => {
  test('should respond to health check within 100ms', async () => {
    const startTime = Date.now();

    await request(app)
      .get('/health')
      .expect(200);

    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(100);
  });

  test('should handle concurrent requests efficiently', async () => {
    const concurrentRequests = 20;
    const startTime = Date.now();

    const promises = Array.from({ length: concurrentRequests }, () =>
      request(app).get('/health').expect(200)
    );

    await Promise.all(promises);

    const totalTime = Date.now() - startTime;
    const avgResponseTime = totalTime / concurrentRequests;

    expect(avgResponseTime).toBeLessThan(200); // 平均200ms以下
  });
});
```

### ストレステスト

```javascript
// tests/performance/stress.test.js
const MonitoringService = require('../../src/services/monitoring');
const DatabaseService = require('../../src/services/database');

describe('Stress Tests', () => {
  let monitoringService;
  let databaseService;

  beforeAll(async () => {
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();
    monitoringService = new MonitoringService(databaseService);
  });

  test('should handle high-frequency monitoring', async () => {
    const urlCount = 100;
    const checkInterval = 100; // 100ms間隔

    // 大量のURL作成
    const urls = [];
    for (let i = 0; i < urlCount; i++) {
      const url = await databaseService.createUrl({
        url: `https://example.com/stress${i}`,
        name: `ストレステスト${i}`,
        userId: 'stress_user',
        interval: checkInterval
      });
      urls.push(url);
    }

    // 高頻度監視実行
    const startTime = Date.now();
    const duration = 10000; // 10秒間

    const results = [];
    while (Date.now() - startTime < duration) {
      const promises = urls.map(url => 
        monitoringService.checkUrl(url.id).catch(error => ({ error }))
      );
      
      const batchResults = await Promise.allSettled(promises);
      results.push(...batchResults);

      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }

    // 結果検証
    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const successRate = successCount / results.length;

    expect(successRate).toBeGreaterThan(0.95); // 95%以上の成功率
  });
});
```

## セキュリティテスト

### 入力値検証テスト

```javascript
// tests/security/input-validation.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Input Validation Security Tests', () => {
  describe('URL validation', () => {
    test('should reject malicious URLs', async () => {
      const maliciousUrls = [
        'javascript:alert("xss")',
        'data:text/html,<script>alert("xss")</script>',
        'file:///etc/passwd',
        'ftp://malicious.com/payload',
        'http://localhost:22/ssh-attack'
      ];

      for (const url of maliciousUrls) {
        const response = await request(app)
          .post('/api/urls')
          .send({
            url,
            name: 'テスト',
            userId: 'test_user'
          })
          .expect(400);

        expect(response.body.error).toContain('Invalid URL');
      }
    });

    test('should accept valid URLs only', async () => {
      const validUrls = [
        'https://suumo.jp/chintai/tokyo/',
        'https://www.homes.co.jp/chintai/',
        'https://athome.co.jp/chintai/'
      ];

      for (const url of validUrls) {
        await request(app)
          .post('/api/urls')
          .send({
            url,
            name: 'テスト',
            userId: 'test_user'
          })
          .expect(201);
      }
    });
  });

  describe('SQL injection prevention', () => {
    test('should prevent SQL injection in URL parameters', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE urls; --",
        "' OR '1'='1",
        "'; INSERT INTO urls VALUES ('malicious'); --"
      ];

      for (const payload of sqlInjectionPayloads) {
        const response = await request(app)
          .get(`/api/urls/${payload}`)
          .expect(400);

        expect(response.body.error).toContain('Invalid');
      }
    });
  });

  describe('XSS prevention', () => {
    test('should sanitize user input', async () => {
      const xssPayloads = [
        '<script>alert("xss")</script>',
        '"><script>alert("xss")</script>',
        'javascript:alert("xss")',
        '<img src="x" onerror="alert(\'xss\')">'
      ];

      for (const payload of xssPayloads) {
        const response = await request(app)
          .post('/api/urls')
          .send({
            url: 'https://suumo.jp/test',
            name: payload,
            userId: 'test_user'
          })
          .expect(201);

        // レスポンスにスクリプトタグが含まれていないことを確認
        expect(response.body.name).not.toContain('<script>');
        expect(response.body.name).not.toContain('javascript:');
      }
    });
  });
});
```

### 認証・認可テスト

```javascript
// tests/security/auth.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Authentication & Authorization Tests', () => {
  describe('API access control', () => {
    test('should require authentication for protected endpoints', async () => {
      const protectedEndpoints = [
        { method: 'post', path: '/api/urls' },
        { method: 'put', path: '/api/urls/test-id' },
        { method: 'delete', path: '/api/urls/test-id' },
        { method: 'get', path: '/api/monitoring/test-id/logs' }
      ];

      for (const endpoint of protectedEndpoints) {
        const response = await request(app)
          [endpoint.method](endpoint.path)
          .expect(401);

        expect(response.body.error).toContain('Unauthorized');
      }
    });

    test('should accept valid authentication', async () => {
      const validToken = 'valid_test_token';

      const response = await request(app)
        .post('/api/urls')
        .set('Authorization', `Bearer ${validToken}`)
        .send({
          url: 'https://suumo.jp/test',
          name: 'テスト',
          userId: 'test_user'
        })
        .expect(201);

      expect(response.body).toHaveProperty('id');
    });
  });

  describe('Rate limiting', () => {
    test('should enforce rate limits', async () => {
      const requests = [];

      // 制限を超えるリクエスト送信
      for (let i = 0; i < 150; i++) {
        requests.push(
          request(app)
            .get('/health')
            .expect(res => {
              expect([200, 429]).toContain(res.status);
            })
        );
      }

      const responses = await Promise.allSettled(requests);
      const rateLimitedCount = responses.filter(
        r => r.value && r.value.status === 429
      ).length;

      expect(rateLimitedCount).toBeGreaterThan(0);
    });
  });
});
```

## テスト環境構築

### テスト用データベース設定

```javascript
// tests/setup.js
const DatabaseService = require('../src/services/database');
const path = require('path');
const fs = require('fs');

// テスト用データベース設定
const TEST_DB_PATH = path.join(__dirname, 'fixtures/test.db');

beforeAll(async () => {
  // テスト用ディレクトリ作成
  const testDir = path.dirname(TEST_DB_PATH);
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }

  // 環境変数設定
  process.env.NODE_ENV = 'test';
  process.env.DATABASE_PATH = TEST_DB_PATH;
  process.env.LOG_LEVEL = 'error';
  process.env.MOCK_TELEGRAM = 'true';
  process.env.MOCK_SCRAPING = 'true';
});

afterAll(async () => {
  // テストデータベース削除
  if (fs.existsSync(TEST_DB_PATH)) {
    fs.unlinkSync(TEST_DB_PATH);
  }
});

// テスト用ヘルパー関数
global.createTestUser = async (databaseService, overrides = {}) => {
  return await databaseService.createUser({
    id: 'test_user_1',
    username: 'testuser',
    firstName: 'テスト',
    lastName: 'ユーザー',
    languageCode: 'ja',
    urlLimit: 3,
    ...overrides
  });
};

global.createTestUrl = async (databaseService, overrides = {}) => {
  return await databaseService.createUrl({
    url: 'https://suumo.jp/test',
    name: 'テスト物件',
    userId: 'test_user_1',
    interval: 300,
    enabled: true,
    ...overrides
  });
};

// メモリ使用量監視
global.measureMemory = (fn) => {
  return async (...args) => {
    const initialMemory = process.memoryUsage().heapUsed;
    const result = await fn(...args);
    const finalMemory = process.memoryUsage().heapUsed;
    
    return {
      result,
      memoryUsed: (finalMemory - initialMemory) / 1024 / 1024 // MB
    };
  };
};
```

### モック設定

```javascript
// tests/mocks/telegram.js
class MockTelegramService {
  constructor() {
    this.sentMessages = [];
    this.commands = [];
  }

  async sendMessage(chatId, text, options = {}) {
    this.sentMessages.push({ chatId, text, options });
    return {
      success: true,
      messageId: Math.floor(Math.random() * 1000000)
    };
  }

  async processCommand(message) {
    this.commands.push(message);
    return {
      command: message.text.split(' ')[0].substring(1),
      success: true
    };
  }

  getLastMessage() {
    return this.sentMessages[this.sentMessages.length - 1];
  }

  getMessageCount() {
    return this.sentMessages.length;
  }

  clearHistory() {
    this.sentMessages = [];
    this.commands = [];
  }
}

module.exports = MockTelegramService;
```

```javascript
// tests/mocks/scraping.js
class MockScrapingService {
  constructor() {
    this.responses = new Map();
    this.defaultResponse = {
      hasNew: true,
      newCount: 3,
      method: 'http-only',
      responseTime: 1500,
      memoryUsage: 25.5,
      botProtection: false
    };
  }

  setResponse(url, response) {
    this.responses.set(url, response);
  }

  async checkNewListings(url, options = {}) {
    const response = this.responses.get(url) || this.defaultResponse;
    
    // Bot対策シミュレーション
    if (options.botProtection) {
      return {
        ...response,
        method: 'google-bypass',
        botProtection: true,
        responseTime: response.responseTime + 2000
      };
    }

    return response;
  }

  clearResponses() {
    this.responses.clear();
  }
}

module.exports = MockScrapingService;
```

## CI/CDパイプライン

### GitHub Actions設定

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop, lightweight-version ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'pnpm'

    - name: Install pnpm
      run: npm install -g pnpm

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run linting
      run: pnpm lint

    - name: Run unit tests
      run: pnpm test:unit --coverage

    - name: Run integration tests
      run: pnpm test:integration

    - name: Run E2E tests
      run: pnpm test:e2e
      timeout-minutes: 10

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

    - name: Performance benchmark
      run: pnpm test:performance

  security:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Run security audit
      run: |
        npm audit --audit-level moderate
        pnpm audit --audit-level moderate

    - name: Run security tests
      run: pnpm test:security
```

### テスト品質メトリクス

#### カバレッジ設定

```javascript
// jest.config.js
module.exports = {
  // ... 他の設定

  collectCoverageFrom: [
    'src/**/*.js',
    '!src/main.js',
    '!src/**/*.test.js',
    '!src/**/*.spec.js',
    '!src/config/**',
    '!src/migrations/**'
  ],

  coverageThreshold: {
    global: {
      branches: 85,
      functions: 85,
      lines: 85,
      statements: 85
    },
    './src/services/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },

  coverageReporters: [
    'text',
    'text-summary',
    'lcov',
    'html',
    'json'
  ]
};
```

#### 品質ゲート

```bash
# scripts/quality-gate.sh
#!/bin/bash

echo "🔍 軽量ソクブツ品質ゲート実行中..."

# 1. リント検査
echo "1. リント検査"
pnpm lint
if [ $? -ne 0 ]; then
  echo "❌ リント検査失敗"
  exit 1
fi

# 2. 単体テスト + カバレッジ
echo "2. 単体テスト実行"
pnpm test:unit --coverage --silent
if [ $? -ne 0 ]; then
  echo "❌ 単体テスト失敗"
  exit 1
fi

# 3. カバレッジ閾値確認
COVERAGE=$(grep -o '"pct":[0-9.]*' coverage/coverage-summary.json | head -1 | cut -d':' -f2)
if (( $(echo "$COVERAGE < 85" | bc -l) )); then
  echo "❌ カバレッジ不足: ${COVERAGE}% (最低85%必要)"
  exit 1
fi

# 4. 統合テスト
echo "3. 統合テスト実行"
pnpm test:integration --silent
if [ $? -ne 0 ]; then
  echo "❌ 統合テスト失敗"
  exit 1
fi

# 5. セキュリティテスト
echo "4. セキュリティテスト実行"
pnpm test:security --silent
if [ $? -ne 0 ]; then
  echo "❌ セキュリティテスト失敗"
  exit 1
fi

# 6. パフォーマンステスト
echo "5. パフォーマンステスト実行"
pnpm test:performance --silent
if [ $? -ne 0 ]; then
  echo "❌ パフォーマンステスト失敗"
  exit 1
fi

echo "✅ 全ての品質ゲートをクリアしました"
echo "📊 カバレッジ: ${COVERAGE}%"
echo "🚀 デプロイ準備完了"
```

## テストデータ管理

### フィクスチャ管理

```javascript
// tests/fixtures/users.js
module.exports = {
  validUser: {
    id: 'test_user_1',
    username: 'testuser',
    firstName: 'テスト',
    lastName: 'ユーザー',
    languageCode: 'ja',
    isActive: true,
    urlLimit: 3
  },

  premiumUser: {
    id: 'premium_user_1',
    username: 'premiumuser',
    firstName: 'プレミアム',
    lastName: 'ユーザー',
    languageCode: 'ja',
    isActive: true,
    urlLimit: 10
  },

  inactiveUser: {
    id: 'inactive_user_1',
    username: 'inactiveuser',
    firstName: '無効',
    lastName: 'ユーザー',
    languageCode: 'ja',
    isActive: false,
    urlLimit: 3
  }
};
```

```javascript
// tests/fixtures/urls.js
module.exports = {
  suumoUrl: {
    url: 'https://suumo.jp/jj/chintai/ichiran/FR301FC001/?ar=030&bs=040',
    name: '渋谷エリア・1K',
    interval: 300,
    enabled: true
  },

  homesUrl: {
    url: 'https://www.homes.co.jp/chintai/tokyo/shibuya-city/',
    name: 'HOMES渋谷',
    interval: 600,
    enabled: true
  },

  disabledUrl: {
    url: 'https://suumo.jp/disabled',
    name: '無効URL',
    interval: 300,
    enabled: false
  }
};
```

### テストデータ生成

```javascript
// tests/utils/data-generator.js
const { v4: uuidv4 } = require('uuid');

class TestDataGenerator {
  static generateUser(overrides = {}) {
    return {
      id: uuidv4(),
      username: `user_${Math.random().toString(36).substr(2, 9)}`,
      firstName: 'テスト',
      lastName: 'ユーザー',
      languageCode: 'ja',
      isActive: true,
      urlLimit: 3,
      ...overrides
    };
  }

  static generateUrl(userId, overrides = {}) {
    const domains = ['suumo.jp', 'homes.co.jp', 'athome.co.jp'];
    const areas = ['shibuya', 'shinjuku', 'ikebukuro', 'ginza'];
    const types = ['1k', '1dk', '1ldk', '2k'];

    const domain = domains[Math.floor(Math.random() * domains.length)];
    const area = areas[Math.floor(Math.random() * areas.length)];
    const type = types[Math.floor(Math.random() * types.length)];

    return {
      id: uuidv4(),
      url: `https://${domain}/chintai/${area}/${type}/`,
      name: `${area}エリア・${type.toUpperCase()}`,
      userId,
      interval: 300 + Math.floor(Math.random() * 600),
      enabled: Math.random() > 0.2, // 80%の確率で有効
      ...overrides
    };
  }

  static generateMonitoringLog(urlId, overrides = {}) {
    const methods = ['http-only', 'jsdom', 'google-bypass'];
    const method = methods[Math.floor(Math.random() * methods.length)];

    return {
      id: uuidv4(),
      urlId,
      newCount: Math.floor(Math.random() * 10),
      hasNew: Math.random() > 0.4, // 60%の確率で新着あり
      method,
      responseTime: 500 + Math.floor(Math.random() * 2000),
      memoryUsage: 20 + Math.random() * 30,
      botProtection: method === 'google-bypass',
      checkedAt: new Date(),
      ...overrides
    };
  }

  static async seedDatabase(databaseService, options = {}) {
    const {
      userCount = 5,
      urlsPerUser = 3,
      logsPerUrl = 10
    } = options;

    const users = [];
    const urls = [];

    // ユーザー作成
    for (let i = 0; i < userCount; i++) {
      const user = await databaseService.createUser(
        this.generateUser({ username: `testuser${i + 1}` })
      );
      users.push(user);

      // URL作成
      for (let j = 0; j < urlsPerUser; j++) {
        const url = await databaseService.createUrl(
          this.generateUrl(user.id)
        );
        urls.push(url);

        // 監視ログ作成
        for (let k = 0; k < logsPerUrl; k++) {
          await databaseService.saveMonitoringLog(
            this.generateMonitoringLog(url.id)
          );
        }
      }
    }

    return { users, urls };
  }
}

module.exports = TestDataGenerator;
```

## ベストプラクティス

### テストコード品質

#### 1. 可読性重視

```javascript
// ❌ 悪い例
test('test1', async () => {
  const r = await s.check('https://suumo.jp/test');
  expect(r.h).toBe(true);
  expect(r.n).toBe(3);
});

// ✅ 良い例
test('should detect new listings when 3 properties are found', async () => {
  // Arrange
  const testUrl = 'https://suumo.jp/test-property-page';
  const expectedNewCount = 3;

  // Act
  const result = await scrapingService.checkNewListings(testUrl);

  // Assert
  expect(result.hasNew).toBe(true);
  expect(result.newCount).toBe(expectedNewCount);
  expect(result.method).toBe('http-only');
});
```

#### 2. 独立性確保

```javascript
// ✅ 各テストが独立している
describe('URL management', () => {
  beforeEach(async () => {
    // 各テスト前にクリーンな状態を作成
    await databaseService.clearAllData();
    await createTestUser(databaseService);
  });

  test('should create URL successfully', async () => {
    // このテストは他のテストの影響を受けない
  });

  test('should update URL successfully', async () => {
    // このテストも独立している
  });
});
```

#### 3. 適切なモック使用

```javascript
// ✅ 外部依存をモック化
test('should handle network timeout gracefully', async () => {
  // 外部APIをモック化
  nock('https://suumo.jp')
    .get('/test-url')
    .socketDelay(30000) // 30秒遅延
    .reply(200, 'response');

  const result = await scrapingService.checkNewListings(
    'https://suumo.jp/test-url',
    { timeout: 5000 }
  );

  expect(result.error).toContain('timeout');
});
```

### パフォーマンス最適化

#### 1. 並列実行

```javascript
// ✅ 独立したテストは並列実行
describe('Multiple URL processing', () => {
  test('should process multiple URLs concurrently', async () => {
    const urls = [
      'https://suumo.jp/url1',
      'https://suumo.jp/url2',
      'https://suumo.jp/url3'
    ];

    // 並列実行でテスト時間短縮
    const results = await Promise.all(
      urls.map(url => scrapingService.checkNewListings(url))
    );

    expect(results).toHaveLength(3);
    results.forEach(result => {
      expect(result).toHaveProperty('hasNew');
    });
  });
});
```

#### 2. テストデータ最小化

```javascript
// ✅ 必要最小限のテストデータ
test('should calculate statistics correctly', async () => {
  const urlId = 'test_url_1';

  // 最小限のテストデータで統計計算をテスト
  const testLogs = [
    { newCount: 0, hasNew: false, responseTime: 1000 },
    { newCount: 3, hasNew: true, responseTime: 1500 },
    { newCount: 1, hasNew: true, responseTime: 800 }
  ];

  for (const log of testLogs) {
    await databaseService.saveMonitoringLog({ urlId, ...log });
  }

  const stats = await databaseService.getMonitoringStats(urlId);
  
  expect(stats.totalChecks).toBe(3);
  expect(stats.newDetections).toBe(2);
  expect(stats.avgResponseTime).toBe(1100);
});
```

### エラーハンドリング

#### 1. 期待されるエラーのテスト

```javascript
// ✅ エラーケースも適切にテスト
test('should throw error for invalid URL format', async () => {
  const invalidUrl = 'not-a-valid-url';

  await expect(
    scrapingService.checkNewListings(invalidUrl)
  ).rejects.toThrow('Invalid URL format');
});

test('should handle network errors gracefully', async () => {
  nock('https://suumo.jp')
    .get('/network-error')
    .replyWithError('ECONNREFUSED');

  const result = await scrapingService.checkNewListings(
    'https://suumo.jp/network-error'
  );

  expect(result.hasNew).toBe(false);
  expect(result.error).toContain('ECONNREFUSED');
});
```

#### 2. 境界値テスト

```javascript
// ✅ 境界値での動作確認
describe('URL limit enforcement', () => {
  test('should allow creation up to limit', async () => {
    const userId = 'test_user_1';
    const urlLimit = 3;

    await databaseService.createUser({
      id: userId,
      username: 'testuser',
      urlLimit
    });

    // 制限値まで作成（成功）
    for (let i = 0; i < urlLimit; i++) {
      await expect(
        databaseService.createUrl({
          url: `https://suumo.jp/test${i}`,
          name: `テスト${i}`,
          userId
        })
      ).resolves.toHaveProperty('id');
    }

    // 制限値を超える作成（失敗）
    await expect(
      databaseService.createUrl({
        url: 'https://suumo.jp/over-limit',
        name: '制限超過',
        userId
      })
    ).rejects.toThrow('URL limit exceeded');
  });
});
```

## まとめ

軽量ソクブツのテスト戦略は、自宅サーバー環境での物件監視システムに特化した包括的なテストソリューションです。

### 主要な特徴

1. **軽量性重視**: メモリ使用量100MB以下でのテスト実行
2. **実用性重視**: 実際の使用パターンに基づくテストケース
3. **自動化重視**: CI/CDパイプラインとの完全統合
4. **品質保証**: 85%以上のコードカバレッジ維持

### 期待される効果

- **品質向上**: 包括的なテストによる高品質なソフトウェア
- **開発効率**: 自動化されたテストによる迅速なフィードバック
- **保守性**: 構造化されたテストコードによる長期保守性
- **信頼性**: 本番環境での安定動作保証

### 技術的優位性

1. **階層化テスト**: 単体→統合→E2Eの効率的なテストピラミッド
2. **パフォーマンステスト**: 軽量アーキテクチャの性能保証
3. **セキュリティテスト**: 包括的なセキュリティ検証
4. **継続的品質管理**: 自動化された品質ゲート

この包括的なテスト戦略により、軽量ソクブツの高品質な開発と安定運用を実現し、物件監視サービスの信頼性を保証します。

