# ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ãƒ»æ‰‹é †æ›¸ - è»½é‡ã‚½ã‚¯ãƒ–ãƒ„

## æ¦‚è¦

è»½é‡ã‚½ã‚¯ãƒ–ãƒ„ã¯ã€è‡ªå®…ã‚µãƒ¼ãƒãƒ¼ç’°å¢ƒã§ã®ç‰©ä»¶æ–°ç€ç›£è¦–ã«ç‰¹åŒ–ã—ãŸã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ã“ã®ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã§ã¯ã€è»½é‡ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆãƒ¡ãƒ¢ãƒª30-60MBã€èµ·å‹•æ™‚é–“1-3ç§’ï¼‰ã®ç‰¹æ€§ã‚’æ´»ã‹ã—ãŸåŠ¹ç‡çš„ãªãƒ†ã‚¹ãƒˆæ‰‹æ³•ã‚’å®šç¾©ã—ã€é«˜å“è³ªãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã‚’æ”¯æ´ã—ã¾ã™ã€‚

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰

è»½é‡ã‚½ã‚¯ãƒ–ãƒ„ã§ã¯ã€åŠ¹ç‡æ€§ã¨å®Ÿç”¨æ€§ã‚’é‡è¦–ã—ãŸãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã‚’æ¡ç”¨ã—ã¾ã™ï¼š

```
        E2E Tests (5%)
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  çµ±åˆãƒ†ã‚¹ãƒˆ (25%)  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚     å˜ä½“ãƒ†ã‚¹ãƒˆ (70%)      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å˜ä½“ãƒ†ã‚¹ãƒˆ (70%)
- **å¯¾è±¡**: å€‹åˆ¥ã®é–¢æ•°ãƒ»ã‚¯ãƒ©ã‚¹ãƒ»ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
- **å®Ÿè¡Œæ™‚é–“**: 1-5ç§’
- **é »åº¦**: é–‹ç™ºä¸­ã®ç¶™ç¶šå®Ÿè¡Œ
- **ãƒ„ãƒ¼ãƒ«**: Jest + Node.jsæ¨™æº–ãƒ†ã‚¹ãƒˆ

#### çµ±åˆãƒ†ã‚¹ãƒˆ (25%)
- **å¯¾è±¡**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã®é€£æºãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»å¤–éƒ¨API
- **å®Ÿè¡Œæ™‚é–“**: 10-30ç§’
- **é »åº¦**: ã‚³ãƒŸãƒƒãƒˆå‰ãƒ»CI/CD
- **ãƒ„ãƒ¼ãƒ«**: Jest + ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹

#### E2Eãƒ†ã‚¹ãƒˆ (5%)
- **å¯¾è±¡**: å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚·ãƒŠãƒªã‚ª
- **å®Ÿè¡Œæ™‚é–“**: 1-3åˆ†
- **é »åº¦**: ãƒªãƒªãƒ¼ã‚¹å‰ãƒ»å®šæœŸå®Ÿè¡Œ
- **ãƒ„ãƒ¼ãƒ«**: Jest + å®Ÿéš›ã®Telegram Bot

### ãƒ†ã‚¹ãƒˆåŸå‰‡

#### 1. è»½é‡æ€§é‡è¦–
- ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ã®æœ€å°åŒ–
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®åˆ¶é™ï¼ˆãƒ†ã‚¹ãƒˆæ™‚100MBä»¥ä¸‹ï¼‰
- ä¸¦åˆ—å®Ÿè¡Œã«ã‚ˆã‚‹åŠ¹ç‡åŒ–

#### 2. å®Ÿç”¨æ€§é‡è¦–
- å®Ÿéš›ã®ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ããƒ†ã‚¹ãƒˆ
- è‡ªå®…ã‚µãƒ¼ãƒãƒ¼ç’°å¢ƒã§ã®å‹•ä½œä¿è¨¼
- Botå¯¾ç­–æ©Ÿèƒ½ã®å®Ÿè¨¼

#### 3. è‡ªå‹•åŒ–é‡è¦–
- CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ã®çµ±åˆ
- è‡ªå‹•ãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
- ç¶™ç¶šçš„å“è³ªç›£è¦–

#### 4. ä¿å®ˆæ€§é‡è¦–
- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§
- ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†
- ãƒ†ã‚¹ãƒˆç’°å¢ƒã®ä¸€è²«æ€§

## å˜ä½“ãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå¯¾è±¡

#### ã‚³ã‚¢ã‚µãƒ¼ãƒ“ã‚¹
- **ScrapingService**: ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°æ©Ÿèƒ½
- **DatabaseService**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ
- **TelegramService**: Telegram Botæ©Ÿèƒ½
- **MonitoringService**: ç›£è¦–æ©Ÿèƒ½

#### ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
- **BotProtection**: Botå¯¾ç­–æ©Ÿèƒ½
- **CacheManager**: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
- **Logger**: ãƒ­ã‚°æ©Ÿèƒ½
- **ConfigManager**: è¨­å®šç®¡ç†

### ãƒ†ã‚¹ãƒˆå®Ÿè£…ä¾‹

#### ScrapingService ãƒ†ã‚¹ãƒˆ

```javascript
// tests/unit/services/scraping.test.js
const ScrapingService = require('../../../src/services/scraping');
const nock = require('nock');

describe('ScrapingService', () => {
  let scrapingService;

  beforeEach(() => {
    scrapingService = new ScrapingService();
    nock.cleanAll();
  });

  afterEach(() => {
    nock.cleanAll();
  });

  describe('checkNewListings', () => {
    test('should detect new listings with HTTP-only method', async () => {
      // ãƒ¢ãƒƒã‚¯HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­å®š
      nock('https://suumo.jp')
        .get('/test-url')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">ç‰©ä»¶1</div>
              <div class="cassetteitem">ç‰©ä»¶2</div>
              <div class="cassetteitem">ç‰©ä»¶3</div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/test-url');

      expect(result).toEqual({
        hasNew: true,
        newCount: 3,
        method: 'http-only',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number),
        botProtection: false
      });
    });

    test('should handle bot protection with Google bypass', async () => {
      // Botæ¤œçŸ¥ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      nock('https://suumo.jp')
        .get('/protected-url')
        .reply(403, 'Access Denied');

      // Googleæ¤œç´¢ãƒ¢ãƒƒã‚¯
      nock('https://www.google.com')
        .get('/search')
        .query(true)
        .reply(200, `
          <html>
            <body>
              <a href="https://suumo.jp/protected-url">ç‰©ä»¶ã‚µã‚¤ãƒˆ</a>
            </body>
          </html>
        `);

      // GoogleçµŒç”±ã‚¢ã‚¯ã‚»ã‚¹æˆåŠŸ
      nock('https://suumo.jp')
        .get('/protected-url')
        .matchHeader('referer', /google\.com/)
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">ç‰©ä»¶1</div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/protected-url', {
        botProtection: true
      });

      expect(result).toEqual({
        hasNew: true,
        newCount: 1,
        method: 'google-bypass',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number),
        botProtection: true
      });
    });

    test('should fallback to JSDOM when HTTP-only fails', async () => {
      // JavaScriptå¿…é ˆã‚µã‚¤ãƒˆã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      nock('https://suumo.jp')
        .get('/js-required')
        .reply(200, `
          <html>
            <body>
              <script>
                document.addEventListener('DOMContentLoaded', function() {
                  const container = document.getElementById('listings');
                  container.innerHTML = '<div class="cassetteitem">å‹•çš„ç‰©ä»¶1</div>';
                });
              </script>
              <div id="listings"></div>
            </body>
          </html>
        `);

      const result = await scrapingService.checkNewListings('https://suumo.jp/js-required');

      expect(result.method).toBe('jsdom');
      expect(result.hasNew).toBe(true);
    });

    test('should handle network errors gracefully', async () => {
      nock('https://suumo.jp')
        .get('/network-error')
        .replyWithError('ECONNREFUSED');

      const result = await scrapingService.checkNewListings('https://suumo.jp/network-error');

      expect(result).toEqual({
        hasNew: false,
        newCount: 0,
        method: 'error',
        error: expect.stringContaining('ECONNREFUSED'),
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number)
      });
    });

    test('should respect memory limits', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      nock('https://suumo.jp')
        .get('/large-page')
        .reply(200, 'x'.repeat(1024 * 1024)); // 1MB ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹

      const result = await scrapingService.checkNewListings('https://suumo.jp/large-page');

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

      expect(memoryIncrease).toBeLessThan(10); // 10MBä»¥ä¸‹ã®å¢—åŠ 
      expect(result.memoryUsage).toBeLessThan(50); // 50MBä»¥ä¸‹ã®ä½¿ç”¨é‡
    });
  });

  describe('extractListingCount', () => {
    test('should extract listing count from SUUMO HTML', () => {
      const html = `
        <div class="cassetteitem">ç‰©ä»¶1</div>
        <div class="cassetteitem">ç‰©ä»¶2</div>
        <div class="cassetteitem">ç‰©ä»¶3</div>
      `;

      const count = scrapingService.extractListingCount(html, 'suumo.jp');
      expect(count).toBe(3);
    });

    test('should extract listing count from HOMES HTML', () => {
      const html = `
        <div class="bukkenList">
          <div class="bukkenItem">ç‰©ä»¶1</div>
          <div class="bukkenItem">ç‰©ä»¶2</div>
        </div>
      `;

      const count = scrapingService.extractListingCount(html, 'homes.co.jp');
      expect(count).toBe(2);
    });

    test('should return 0 for unknown site format', () => {
      const html = '<div>Some content</div>';
      const count = scrapingService.extractListingCount(html, 'unknown-site.com');
      expect(count).toBe(0);
    });
  });
});
```

#### DatabaseService ãƒ†ã‚¹ãƒˆ

```javascript
// tests/unit/services/database.test.js
const DatabaseService = require('../../../src/services/database');
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

describe('DatabaseService', () => {
  let databaseService;
  let testDbPath;

  beforeEach(() => {
    testDbPath = path.join(__dirname, '../../fixtures/test.db');
    
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½œæˆ
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
    
    databaseService = new DatabaseService(testDbPath);
    databaseService.initialize();
  });

  afterEach(() => {
    if (databaseService.db) {
      databaseService.db.close();
    }
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
  });

  describe('URL management', () => {
    test('should create URL successfully', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId: 'test_user_1',
        interval: 300
      };

      const result = await databaseService.createUrl(urlData);

      expect(result).toHaveProperty('id');
      expect(result.url).toBe(urlData.url);
      expect(result.name).toBe(urlData.name);
      expect(result.enabled).toBe(true);
    });

    test('should prevent duplicate URLs for same user', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId: 'test_user_1',
        interval: 300
      };

      await databaseService.createUrl(urlData);

      await expect(databaseService.createUrl(urlData))
        .rejects.toThrow('URL already exists for this user');
    });

    test('should enforce URL limit per user', async () => {
      const userId = 'test_user_1';
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®URLåˆ¶é™ã‚’2ã«è¨­å®š
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 2
      });

      // 2ã¤ã®URLä½œæˆï¼ˆæˆåŠŸï¼‰
      await databaseService.createUrl({
        url: 'https://suumo.jp/test1',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶1',
        userId,
        interval: 300
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/test2',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶2',
        userId,
        interval: 300
      });

      // 3ã¤ç›®ã®URLä½œæˆï¼ˆå¤±æ•—ï¼‰
      await expect(databaseService.createUrl({
        url: 'https://suumo.jp/test3',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶3',
        userId,
        interval: 300
      })).rejects.toThrow('URL limit exceeded');
    });

    test('should get active URLs for monitoring', async () => {
      const userId = 'test_user_1';

      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªURL
      await databaseService.createUrl({
        url: 'https://suumo.jp/active',
        name: 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç‰©ä»¶',
        userId,
        enabled: true
      });

      // ç„¡åŠ¹ãªURL
      await databaseService.createUrl({
        url: 'https://suumo.jp/inactive',
        name: 'ç„¡åŠ¹ç‰©ä»¶',
        userId,
        enabled: false
      });

      const activeUrls = await databaseService.getActiveUrls();

      expect(activeUrls).toHaveLength(1);
      expect(activeUrls[0].url).toBe('https://suumo.jp/active');
    });
  });

  describe('Monitoring logs', () => {
    test('should save monitoring log', async () => {
      const urlId = 'test_url_1';
      const logData = {
        urlId,
        newCount: 5,
        hasNew: true,
        method: 'http-only',
        responseTime: 1500,
        memoryUsage: 25.5,
        botProtection: false
      };

      const result = await databaseService.saveMonitoringLog(logData);

      expect(result).toHaveProperty('id');
      expect(result.newCount).toBe(5);
      expect(result.hasNew).toBe(true);
      expect(result.method).toBe('http-only');
    });

    test('should get recent monitoring logs', async () => {
      const urlId = 'test_url_1';

      // è¤‡æ•°ã®ãƒ­ã‚°ã‚’ä½œæˆ
      for (let i = 0; i < 5; i++) {
        await databaseService.saveMonitoringLog({
          urlId,
          newCount: i,
          hasNew: i > 0,
          method: 'http-only',
          responseTime: 1000 + i * 100
        });
      }

      const recentLogs = await databaseService.getRecentLogs(urlId, 3);

      expect(recentLogs).toHaveLength(3);
      expect(recentLogs[0].newCount).toBe(4); // æœ€æ–°ãŒæœ€åˆ
      expect(recentLogs[2].newCount).toBe(2);
    });

    test('should calculate monitoring statistics', async () => {
      const urlId = 'test_url_1';

      // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
      const testData = [
        { newCount: 0, hasNew: false, responseTime: 1000, method: 'http-only' },
        { newCount: 3, hasNew: true, responseTime: 1500, method: 'http-only' },
        { newCount: 0, hasNew: false, responseTime: 800, method: 'http-only' },
        { newCount: 2, hasNew: true, responseTime: 1200, method: 'jsdom' },
        { newCount: 1, hasNew: true, responseTime: 2000, method: 'jsdom' }
      ];

      for (const data of testData) {
        await databaseService.saveMonitoringLog({ urlId, ...data });
      }

      const stats = await databaseService.getMonitoringStats(urlId);

      expect(stats).toEqual({
        totalChecks: 5,
        newDetections: 3,
        detectionRate: 0.6,
        avgResponseTime: 1300,
        methodDistribution: {
          'http-only': 3,
          'jsdom': 2
        },
        avgNewCount: 1.2
      });
    });
  });

  describe('Performance', () => {
    test('should handle large dataset efficiently', async () => {
      const startTime = Date.now();
      const urlId = 'test_url_1';

      // 1000ä»¶ã®ãƒ­ã‚°ã‚’æŒ¿å…¥
      const insertPromises = [];
      for (let i = 0; i < 1000; i++) {
        insertPromises.push(databaseService.saveMonitoringLog({
          urlId,
          newCount: Math.floor(Math.random() * 10),
          hasNew: Math.random() > 0.5,
          method: 'http-only',
          responseTime: 1000 + Math.random() * 1000
        }));
      }

      await Promise.all(insertPromises);

      const insertTime = Date.now() - startTime;
      expect(insertTime).toBeLessThan(5000); // 5ç§’ä»¥å†…

      // ã‚¯ã‚¨ãƒªæ€§èƒ½ãƒ†ã‚¹ãƒˆ
      const queryStartTime = Date.now();
      const recentLogs = await databaseService.getRecentLogs(urlId, 100);
      const queryTime = Date.now() - queryStartTime;

      expect(recentLogs).toHaveLength(100);
      expect(queryTime).toBeLessThan(100); // 100msä»¥å†…
    });

    test('should maintain memory usage under limits', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      // å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿æ“ä½œ
      for (let i = 0; i < 100; i++) {
        await databaseService.saveMonitoringLog({
          urlId: `test_url_${i}`,
          newCount: i,
          hasNew: true,
          method: 'http-only',
          responseTime: 1000
        });
      }

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

      expect(memoryIncrease).toBeLessThan(20); // 20MBä»¥ä¸‹ã®å¢—åŠ 
    });
  });
});
```

#### TelegramService ãƒ†ã‚¹ãƒˆ

```javascript
// tests/unit/services/telegram.test.js
const TelegramService = require('../../../src/services/telegram');
const nock = require('nock');

describe('TelegramService', () => {
  let telegramService;
  const mockBotToken = 'test_bot_token';

  beforeEach(() => {
    telegramService = new TelegramService(mockBotToken);
    nock.cleanAll();
  });

  afterEach(() => {
    nock.cleanAll();
  });

  describe('sendMessage', () => {
    test('should send message successfully', async () => {
      const chatId = 'test_chat_id';
      const message = 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸';

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, {
          ok: true,
          result: {
            message_id: 123,
            chat: { id: chatId },
            text: message
          }
        });

      const result = await telegramService.sendMessage(chatId, message);

      expect(result).toEqual({
        success: true,
        messageId: 123
      });
    });

    test('should handle rate limiting', async () => {
      const chatId = 'test_chat_id';
      const message = 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸';

      // æœ€åˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ãƒ¬ãƒ¼ãƒˆåˆ¶é™
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(429, {
          ok: false,
          error_code: 429,
          description: 'Too Many Requests: retry after 1'
        });

      // 2å›ç›®ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§æˆåŠŸ
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, {
          ok: true,
          result: { message_id: 123 }
        });

      const result = await telegramService.sendMessage(chatId, message);

      expect(result.success).toBe(true);
    });

    test('should split long messages', async () => {
      const chatId = 'test_chat_id';
      const longMessage = 'x'.repeat(5000); // 4096æ–‡å­—åˆ¶é™ã‚’è¶…ãˆã‚‹

      // 2ã¤ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«åˆ†å‰²ã•ã‚Œã‚‹ã“ã¨ã‚’æœŸå¾…
      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .times(2)
        .reply(200, {
          ok: true,
          result: { message_id: 123 }
        });

      const result = await telegramService.sendMessage(chatId, longMessage);

      expect(result.success).toBe(true);
      expect(result.messageCount).toBe(2);
    });
  });

  describe('processCommand', () => {
    test('should handle /start command', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id', username: 'testuser' },
        text: '/start'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('start');
      expect(result.success).toBe(true);
    });

    test('should handle /add command with URL', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id' },
        text: '/add https://suumo.jp/test æ¸‹è°·1K'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('add');
      expect(result.params).toEqual({
        url: 'https://suumo.jp/test',
        name: 'æ¸‹è°·1K'
      });
    });

    test('should handle invalid commands gracefully', async () => {
      const message = {
        chat: { id: 'test_chat_id' },
        from: { id: 'test_user_id' },
        text: '/invalid_command'
      };

      nock('https://api.telegram.org')
        .post(`/bot${mockBotToken}/sendMessage`)
        .reply(200, { ok: true, result: { message_id: 123 } });

      const result = await telegramService.processCommand(message);

      expect(result.command).toBe('unknown');
      expect(result.success).toBe(true);
    });
  });

  describe('formatNotification', () => {
    test('should format new listing notification', () => {
      const data = {
        urlName: 'æ¸‹è°·1Kç‰©ä»¶',
        newCount: 3,
        totalChecked: 150,
        url: 'https://suumo.jp/test',
        method: 'http-only',
        responseTime: 1500
      };

      const formatted = telegramService.formatNotification('new_listings', data);

      expect(formatted).toContain('ğŸ  æ–°ç€ç‰©ä»¶ç™ºè¦‹ï¼');
      expect(formatted).toContain('æ¸‹è°·1Kç‰©ä»¶');
      expect(formatted).toContain('3ä»¶ã®æ–°ç€');
      expect(formatted).toContain('https://suumo.jp/test');
    });

    test('should format hourly summary notification', () => {
      const data = {
        urlName: 'æ¸‹è°·1Kç‰©ä»¶',
        checksCount: 12,
        newDetections: 2,
        avgResponseTime: 1200,
        method: 'http-only'
      };

      const formatted = telegramService.formatNotification('hourly_summary', data);

      expect(formatted).toContain('ğŸ“Š 1æ™‚é–“ã‚µãƒãƒªãƒ¼');
      expect(formatted).toContain('æ¸‹è°·1Kç‰©ä»¶');
      expect(formatted).toContain('12å›ãƒã‚§ãƒƒã‚¯');
      expect(formatted).toContain('2å›æ–°ç€æ¤œå‡º');
    });
  });
});
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

#### åŸºæœ¬å®Ÿè¡Œ

```bash
# å…¨å˜ä½“ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pnpm test:unit

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«
pnpm test tests/unit/services/scraping.test.js

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
pnpm test --testNamePattern="should detect new listings"

# ç›£è¦–ãƒ¢ãƒ¼ãƒ‰ï¼ˆé–‹ç™ºæ™‚ï¼‰
pnpm test:unit --watch
```

#### ã‚«ãƒãƒ¬ãƒƒã‚¸æ¸¬å®š

```bash
# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pnpm test:unit --coverage

# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆç¢ºèª
open coverage/lcov-report/index.html

# ã‚«ãƒãƒ¬ãƒƒã‚¸é–¾å€¤è¨­å®šï¼ˆjest.config.jsï¼‰
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

## çµ±åˆãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå¯¾è±¡

#### APIçµ±åˆãƒ†ã‚¹ãƒˆ
- REST APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
- ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- èªè¨¼ãƒ»èªå¯

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆãƒ†ã‚¹ãƒˆ
- CRUDæ“ä½œã®é€£æº
- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
- ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

#### å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆãƒ†ã‚¹ãƒˆ
- Telegram APIé€£æº
- ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å¯¾è±¡ã‚µã‚¤ãƒˆ
- Botå¯¾ç­–æ©Ÿèƒ½
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å‡¦ç†

### ãƒ†ã‚¹ãƒˆå®Ÿè£…ä¾‹

#### APIçµ±åˆãƒ†ã‚¹ãƒˆ

```javascript
// tests/integration/api.test.js
const request = require('supertest');
const app = require('../../src/app');
const DatabaseService = require('../../src/services/database');

describe('API Integration Tests', () => {
  let databaseService;

  beforeAll(async () => {
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();
    
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
    app.set('database', databaseService);
  });

  afterAll(async () => {
    if (databaseService.db) {
      databaseService.db.close();
    }
  });

  beforeEach(async () => {
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
    await databaseService.clearAllData();
  });

  describe('GET /health', () => {
    test('should return health status', async () => {
      const response = await request(app)
        .get('/health')
        .expect(200);

      expect(response.body).toEqual({
        status: 'ok',
        timestamp: expect.any(String),
        uptime: expect.any(Number),
        memory: {
          used: expect.any(Number),
          total: expect.any(Number)
        },
        database: 'connected'
      });
    });

    test('should return detailed health status', async () => {
      const response = await request(app)
        .get('/health/detailed')
        .expect(200);

      expect(response.body).toHaveProperty('status', 'ok');
      expect(response.body).toHaveProperty('services');
      expect(response.body.services).toHaveProperty('database');
      expect(response.body.services).toHaveProperty('scraping');
      expect(response.body.services).toHaveProperty('telegram');
    });
  });

  describe('POST /api/urls', () => {
    test('should create URL successfully', async () => {
      const urlData = {
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId: 'test_user_1',
        interval: 300
      };

      const response = await request(app)
        .post('/api/urls')
        .send(urlData)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.url).toBe(urlData.url);
      expect(response.body.name).toBe(urlData.name);
      expect(response.body.enabled).toBe(true);
    });

    test('should validate URL format', async () => {
      const invalidUrlData = {
        url: 'invalid-url',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId: 'test_user_1'
      };

      const response = await request(app)
        .post('/api/urls')
        .send(invalidUrlData)
        .expect(400);

      expect(response.body).toHaveProperty('error');
      expect(response.body.error).toContain('Invalid URL format');
    });

    test('should enforce URL limit', async () => {
      const userId = 'test_user_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆï¼ˆURLåˆ¶é™2ï¼‰
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 2
      });

      // 2ã¤ã®URLä½œæˆï¼ˆæˆåŠŸï¼‰
      for (let i = 1; i <= 2; i++) {
        await request(app)
          .post('/api/urls')
          .send({
            url: `https://suumo.jp/test${i}`,
            name: `ãƒ†ã‚¹ãƒˆç‰©ä»¶${i}`,
            userId,
            interval: 300
          })
          .expect(201);
      }

      // 3ã¤ç›®ã®URLä½œæˆï¼ˆå¤±æ•—ï¼‰
      const response = await request(app)
        .post('/api/urls')
        .send({
          url: 'https://suumo.jp/test3',
          name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶3',
          userId,
          interval: 300
        })
        .expect(400);

      expect(response.body.error).toContain('URL limit exceeded');
    });
  });

  describe('GET /api/urls/:userId', () => {
    test('should get user URLs', async () => {
      const userId = 'test_user_1';

      // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
      await databaseService.createUrl({
        url: 'https://suumo.jp/test1',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶1',
        userId,
        enabled: true
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/test2',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶2',
        userId,
        enabled: false
      });

      const response = await request(app)
        .get(`/api/urls/${userId}`)
        .expect(200);

      expect(response.body).toHaveLength(2);
      expect(response.body[0]).toHaveProperty('url');
      expect(response.body[0]).toHaveProperty('name');
      expect(response.body[0]).toHaveProperty('enabled');
    });

    test('should filter by enabled status', async () => {
      const userId = 'test_user_1';

      // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
      await databaseService.createUrl({
        url: 'https://suumo.jp/active',
        name: 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç‰©ä»¶',
        userId,
        enabled: true
      });

      await databaseService.createUrl({
        url: 'https://suumo.jp/inactive',
        name: 'ç„¡åŠ¹ç‰©ä»¶',
        userId,
        enabled: false
      });

      const response = await request(app)
        .get(`/api/urls/${userId}?enabled=true`)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0].enabled).toBe(true);
    });
  });

  describe('PUT /api/urls/:id', () => {
    test('should update URL successfully', async () => {
      // URLä½œæˆ
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'å…ƒã®åå‰',
        userId: 'test_user_1',
        interval: 300
      });

      const updateData = {
        name: 'æ›´æ–°ã•ã‚ŒãŸåå‰',
        interval: 600,
        enabled: false
      };

      const response = await request(app)
        .put(`/api/urls/${url.id}`)
        .send(updateData)
        .expect(200);

      expect(response.body.name).toBe('æ›´æ–°ã•ã‚ŒãŸåå‰');
      expect(response.body.interval).toBe(600);
      expect(response.body.enabled).toBe(false);
    });

    test('should return 404 for non-existent URL', async () => {
      const response = await request(app)
        .put('/api/urls/non-existent-id')
        .send({ name: 'æ›´æ–°' })
        .expect(404);

      expect(response.body.error).toContain('URL not found');
    });
  });

  describe('DELETE /api/urls/:id', () => {
    test('should delete URL successfully', async () => {
      // URLä½œæˆ
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId: 'test_user_1'
      });

      await request(app)
        .delete(`/api/urls/${url.id}`)
        .expect(204);

      // å‰Šé™¤ç¢ºèª
      const urls = await databaseService.getUserUrls('test_user_1');
      expect(urls).toHaveLength(0);
    });
  });

  describe('GET /api/monitoring/:urlId/logs', () => {
    test('should get monitoring logs', async () => {
      const urlId = 'test_url_1';

      // ãƒ†ã‚¹ãƒˆãƒ­ã‚°ä½œæˆ
      for (let i = 0; i < 5; i++) {
        await databaseService.saveMonitoringLog({
          urlId,
          newCount: i,
          hasNew: i > 0,
          method: 'http-only',
          responseTime: 1000 + i * 100
        });
      }

      const response = await request(app)
        .get(`/api/monitoring/${urlId}/logs?limit=3`)
        .expect(200);

      expect(response.body).toHaveLength(3);
      expect(response.body[0].newCount).toBe(4); // æœ€æ–°ãŒæœ€åˆ
    });

    test('should get monitoring statistics', async () => {
      const urlId = 'test_url_1';

      // ãƒ†ã‚¹ãƒˆãƒ­ã‚°ä½œæˆ
      await databaseService.saveMonitoringLog({
        urlId,
        newCount: 3,
        hasNew: true,
        method: 'http-only',
        responseTime: 1500
      });

      await databaseService.saveMonitoringLog({
        urlId,
        newCount: 0,
        hasNew: false,
        method: 'http-only',
        responseTime: 1000
      });

      const response = await request(app)
        .get(`/api/monitoring/${urlId}/stats`)
        .expect(200);

      expect(response.body).toEqual({
        totalChecks: 2,
        newDetections: 1,
        detectionRate: 0.5,
        avgResponseTime: 1250,
        methodDistribution: {
          'http-only': 2
        },
        avgNewCount: 1.5
      });
    });
  });
});
```

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆãƒ†ã‚¹ãƒˆ

```javascript
// tests/integration/database.test.js
const DatabaseService = require('../../src/services/database');
const path = require('path');
const fs = require('fs');

describe('Database Integration Tests', () => {
  let databaseService;
  let testDbPath;

  beforeAll(() => {
    testDbPath = path.join(__dirname, '../fixtures/integration_test.db');
  });

  beforeEach(async () => {
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½œæˆ
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
    
    databaseService = new DatabaseService(testDbPath);
    await databaseService.initialize();
  });

  afterEach(async () => {
    if (databaseService.db) {
      databaseService.db.close();
    }
    if (fs.existsSync(testDbPath)) {
      fs.unlinkSync(testDbPath);
    }
  });

  describe('Transaction handling', () => {
    test('should rollback on error', async () => {
      const userId = 'test_user_1';

      try {
        await databaseService.db.transaction(() => {
          // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
          databaseService.createUser({
            id: userId,
            username: 'testuser'
          });

          // æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿ
          throw new Error('Test error');
        })();
      } catch (error) {
        // ã‚¨ãƒ©ãƒ¼ã¯æœŸå¾…ã•ã‚Œã‚‹
      }

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½œæˆã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
      const user = await databaseService.getUser(userId);
      expect(user).toBeNull();
    });

    test('should commit on success', async () => {
      const userId = 'test_user_1';

      await databaseService.db.transaction(() => {
        databaseService.createUser({
          id: userId,
          username: 'testuser'
        });

        databaseService.createUrl({
          url: 'https://suumo.jp/test',
          name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
          userId
        });
      })();

      // ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const user = await databaseService.getUser(userId);
      const urls = await databaseService.getUserUrls(userId);

      expect(user).not.toBeNull();
      expect(urls).toHaveLength(1);
    });
  });

  describe('Concurrent access', () => {
    test('should handle concurrent URL creation', async () => {
      const userId = 'test_user_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        urlLimit: 5
      });

      // ä¸¦è¡Œã—ã¦URLä½œæˆ
      const promises = [];
      for (let i = 0; i < 3; i++) {
        promises.push(
          databaseService.createUrl({
            url: `https://suumo.jp/test${i}`,
            name: `ãƒ†ã‚¹ãƒˆç‰©ä»¶${i}`,
            userId
          })
        );
      }

      const results = await Promise.all(promises);

      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toHaveProperty('id');
      });

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ­£ã—ãä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const urls = await databaseService.getUserUrls(userId);
      expect(urls).toHaveLength(3);
    });

    test('should handle concurrent monitoring log creation', async () => {
      const urlId = 'test_url_1';

      // ä¸¦è¡Œã—ã¦ãƒ­ã‚°ä½œæˆ
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(
          databaseService.saveMonitoringLog({
            urlId,
            newCount: i,
            hasNew: i % 2 === 0,
            method: 'http-only',
            responseTime: 1000 + i * 100
          })
        );
      }

      const results = await Promise.all(promises);

      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result).toHaveProperty('id');
      });

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ­£ã—ãä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const logs = await databaseService.getRecentLogs(urlId, 20);
      expect(logs).toHaveLength(10);
    });
  });

  describe('Data integrity', () => {
    test('should maintain foreign key constraints', async () => {
      const userId = 'test_user_1';
      const urlId = 'test_url_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆã›ãšã«URLã‚’ä½œæˆã—ã‚ˆã†ã¨ã™ã‚‹
      await expect(
        databaseService.createUrl({
          url: 'https://suumo.jp/test',
          name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
          userId: 'non_existent_user'
        })
      ).rejects.toThrow();

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆå¾Œã«URLä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId
      });

      // URLã‚’å‰Šé™¤ã›ãšã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã™ã‚‹
      await expect(
        databaseService.deleteUser(userId)
      ).rejects.toThrow();

      // URLå‰Šé™¤å¾Œã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
      await databaseService.deleteUrl(url.id);
      await databaseService.deleteUser(userId);

      // å‰Šé™¤ç¢ºèª
      const user = await databaseService.getUser(userId);
      expect(user).toBeNull();
    });

    test('should cascade delete properly', async () => {
      const userId = 'test_user_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨URLä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test',
        name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
        userId
      });

      // ç›£è¦–ãƒ­ã‚°ä½œæˆ
      await databaseService.saveMonitoringLog({
        urlId: url.id,
        newCount: 3,
        hasNew: true,
        method: 'http-only'
      });

      // URLå‰Šé™¤ï¼ˆã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å‰Šé™¤ï¼‰
      await databaseService.deleteUrl(url.id);

      // é–¢é€£ã™ã‚‹ç›£è¦–ãƒ­ã‚°ã‚‚å‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const logs = await databaseService.getRecentLogs(url.id, 10);
      expect(logs).toHaveLength(0);
    });
  });

  describe('Performance under load', () => {
    test('should handle large dataset efficiently', async () => {
      const startTime = Date.now();

      // å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ä½œæˆ
      const userPromises = [];
      for (let i = 0; i < 100; i++) {
        userPromises.push(
          databaseService.createUser({
            id: `user_${i}`,
            username: `user${i}`
          })
        );
      }
      await Promise.all(userPromises);

      const urlPromises = [];
      for (let i = 0; i < 500; i++) {
        urlPromises.push(
          databaseService.createUrl({
            url: `https://suumo.jp/test${i}`,
            name: `ãƒ†ã‚¹ãƒˆç‰©ä»¶${i}`,
            userId: `user_${i % 100}`
          })
        );
      }
      await Promise.all(urlPromises);

      const setupTime = Date.now() - startTime;
      expect(setupTime).toBeLessThan(10000); // 10ç§’ä»¥å†…

      // ã‚¯ã‚¨ãƒªæ€§èƒ½ãƒ†ã‚¹ãƒˆ
      const queryStartTime = Date.now();
      const activeUrls = await databaseService.getActiveUrls();
      const queryTime = Date.now() - queryStartTime;

      expect(activeUrls).toHaveLength(500);
      expect(queryTime).toBeLessThan(500); // 500msä»¥å†…
    });
  });
});
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pnpm test:integration

# ç‰¹å®šã®çµ±åˆãƒ†ã‚¹ãƒˆ
pnpm test tests/integration/api.test.js

# çµ±åˆãƒ†ã‚¹ãƒˆ + ã‚«ãƒãƒ¬ãƒƒã‚¸
pnpm test:integration --coverage
```

## E2Eãƒ†ã‚¹ãƒˆ

### ãƒ†ã‚¹ãƒˆå¯¾è±¡

#### å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‹ã‚‰URLç›£è¦–ã¾ã§
- æ–°ç€æ¤œå‡ºã‹ã‚‰é€šçŸ¥é€ä¿¡ã¾ã§
- ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã‹ã‚‰å¾©æ—§ã¾ã§

#### ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚·ãƒŠãƒªã‚ª
- Telegram Botã§ã®æ“ä½œ
- è¤‡æ•°URLç®¡ç†
- é€šçŸ¥è¨­å®šå¤‰æ›´

### ãƒ†ã‚¹ãƒˆå®Ÿè£…ä¾‹

```javascript
// tests/e2e/full-workflow.test.js
const TelegramBot = require('node-telegram-bot-api');
const DatabaseService = require('../../src/services/database');
const ScrapingService = require('../../src/services/scraping');
const MonitoringService = require('../../src/services/monitoring');
const nock = require('nock');

describe('E2E Full Workflow Tests', () => {
  let databaseService;
  let scrapingService;
  let monitoringService;
  let mockBot;

  beforeAll(async () => {
    // ãƒ†ã‚¹ãƒˆç’°å¢ƒåˆæœŸåŒ–
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();

    scrapingService = new ScrapingService();
    monitoringService = new MonitoringService(databaseService, scrapingService);

    // Telegram Bot ãƒ¢ãƒƒã‚¯
    mockBot = {
      sendMessage: jest.fn().mockResolvedValue({ message_id: 123 }),
      on: jest.fn()
    };
  });

  beforeEach(() => {
    nock.cleanAll();
    jest.clearAllMocks();
  });

  describe('Complete user journey', () => {
    test('should complete full workflow from registration to notification', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      // 2. URLè¿½åŠ 
      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/test-property',
        name: 'æ¸‹è°·1Kç‰©ä»¶',
        userId,
        interval: 300
      });

      // 3. ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°çµæœãƒ¢ãƒƒã‚¯ï¼ˆæ–°ç€ã‚ã‚Šï¼‰
      nock('https://suumo.jp')
        .get('/test-property')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">ç‰©ä»¶1</div>
              <div class="cassetteitem">ç‰©ä»¶2</div>
              <div class="cassetteitem">ç‰©ä»¶3</div>
            </body>
          </html>
        `);

      // 4. ç›£è¦–å®Ÿè¡Œ
      const monitoringResult = await monitoringService.checkUrl(url.id);

      // 5. çµæœæ¤œè¨¼
      expect(monitoringResult).toEqual({
        urlId: url.id,
        hasNew: true,
        newCount: 3,
        method: 'http-only',
        responseTime: expect.any(Number),
        memoryUsage: expect.any(Number)
      });

      // 6. é€šçŸ¥é€ä¿¡ç¢ºèª
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('ğŸ  æ–°ç€ç‰©ä»¶ç™ºè¦‹ï¼')
      );

      // 7. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨˜éŒ²ç¢ºèª
      const logs = await databaseService.getRecentLogs(url.id, 1);
      expect(logs).toHaveLength(1);
      expect(logs[0].hasNew).toBe(true);
      expect(logs[0].newCount).toBe(3);
    });

    test('should handle bot protection workflow', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨URLä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/protected-property',
        name: 'Botå¯¾ç­–ç‰©ä»¶',
        userId,
        interval: 300
      });

      // Botæ¤œçŸ¥ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      nock('https://suumo.jp')
        .get('/protected-property')
        .reply(403, 'Access Denied');

      // Googleæ¤œç´¢ãƒ¢ãƒƒã‚¯
      nock('https://www.google.com')
        .get('/search')
        .query(true)
        .reply(200, `
          <html>
            <body>
              <a href="https://suumo.jp/protected-property">ç‰©ä»¶ã‚µã‚¤ãƒˆ</a>
            </body>
          </html>
        `);

      // GoogleçµŒç”±ã‚¢ã‚¯ã‚»ã‚¹æˆåŠŸ
      nock('https://suumo.jp')
        .get('/protected-property')
        .matchHeader('referer', /google\.com/)
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">ä¿è­·ã•ã‚ŒãŸç‰©ä»¶1</div>
              <div class="cassetteitem">ä¿è­·ã•ã‚ŒãŸç‰©ä»¶2</div>
            </body>
          </html>
        `);

      // ç›£è¦–å®Ÿè¡Œ
      const monitoringResult = await monitoringService.checkUrl(url.id);

      // Botå¯¾ç­–ãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(monitoringResult.method).toBe('google-bypass');
      expect(monitoringResult.botProtection).toBe(true);
      expect(monitoringResult.hasNew).toBe(true);
      expect(monitoringResult.newCount).toBe(2);

      // é€šçŸ¥é€ä¿¡ç¢ºèª
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('ğŸ›¡ï¸ Botå¯¾ç­–ã‚’é©ç”¨ã—ã¦æ–°ç€ç‰©ä»¶ã‚’ç™ºè¦‹')
      );
    });

    test('should handle error recovery workflow', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨URLä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/error-property',
        name: 'ã‚¨ãƒ©ãƒ¼ç‰©ä»¶',
        userId,
        interval: 300
      });

      // 1å›ç›®: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
      nock('https://suumo.jp')
        .get('/error-property')
        .replyWithError('ECONNREFUSED');

      let monitoringResult = await monitoringService.checkUrl(url.id);

      expect(monitoringResult.method).toBe('error');
      expect(monitoringResult.hasNew).toBe(false);
      expect(monitoringResult.error).toContain('ECONNREFUSED');

      // ã‚¨ãƒ©ãƒ¼é€šçŸ¥ç¢ºèª
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('âš ï¸ ç›£è¦–ã‚¨ãƒ©ãƒ¼')
      );

      // 2å›ç›®: å¾©æ—§æˆåŠŸ
      nock('https://suumo.jp')
        .get('/error-property')
        .reply(200, `
          <html>
            <body>
              <div class="cassetteitem">å¾©æ—§å¾Œç‰©ä»¶1</div>
            </body>
          </html>
        `);

      monitoringResult = await monitoringService.checkUrl(url.id);

      expect(monitoringResult.method).toBe('http-only');
      expect(monitoringResult.hasNew).toBe(true);
      expect(monitoringResult.newCount).toBe(1);

      // å¾©æ—§é€šçŸ¥ç¢ºèª
      expect(mockBot.sendMessage).toHaveBeenCalledWith(
        chatId,
        expect.stringContaining('âœ… ç›£è¦–å¾©æ—§')
      );
    });
  });

  describe('Multiple URL management', () => {
    test('should handle multiple URLs for single user', async () => {
      const userId = 'test_user_1';
      const chatId = 'test_chat_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser',
        chatId: chatId,
        urlLimit: 3
      });

      // è¤‡æ•°URLä½œæˆ
      const urls = [];
      for (let i = 1; i <= 3; i++) {
        const url = await databaseService.createUrl({
          url: `https://suumo.jp/property${i}`,
          name: `ç‰©ä»¶${i}`,
          userId,
          interval: 300
        });
        urls.push(url);

        // å„URLã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒƒã‚¯
        nock('https://suumo.jp')
          .get(`/property${i}`)
          .reply(200, `
            <html>
              <body>
                ${Array.from({length: i}, (_, j) => `<div class="cassetteitem">ç‰©ä»¶${i}-${j+1}</div>`).join('')}
              </body>
            </html>
          `);
      }

      // å…¨URLç›£è¦–å®Ÿè¡Œ
      const results = await Promise.all(
        urls.map(url => monitoringService.checkUrl(url.id))
      );

      // çµæœæ¤œè¨¼
      expect(results).toHaveLength(3);
      results.forEach((result, index) => {
        expect(result.hasNew).toBe(true);
        expect(result.newCount).toBe(index + 1);
      });

      // é€šçŸ¥é€ä¿¡ç¢ºèªï¼ˆå„URLã”ã¨ï¼‰
      expect(mockBot.sendMessage).toHaveBeenCalledTimes(3);
    });

    test('should handle URL enable/disable workflow', async () => {
      const userId = 'test_user_1';

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨URLä½œæˆ
      await databaseService.createUser({
        id: userId,
        username: 'testuser'
      });

      const url = await databaseService.createUrl({
        url: 'https://suumo.jp/toggle-property',
        name: 'ãƒˆã‚°ãƒ«ç‰©ä»¶',
        userId,
        enabled: true
      });

      // æœ‰åŠ¹çŠ¶æ…‹ã§ã®ç›£è¦–
      nock('https://suumo.jp')
        .get('/toggle-property')
        .reply(200, '<div class="cassetteitem">ç‰©ä»¶1</div>');

      let activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(1);

      let result = await monitoringService.checkUrl(url.id);
      expect(result.hasNew).toBe(true);

      // URLç„¡åŠ¹åŒ–
      await databaseService.updateUrl(url.id, { enabled: false });

      activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(0);

      // ç„¡åŠ¹çŠ¶æ…‹ã§ã¯ç›£è¦–ã•ã‚Œãªã„
      const disabledResult = await monitoringService.checkUrl(url.id);
      expect(disabledResult).toBeNull();

      // URLå†æœ‰åŠ¹åŒ–
      await databaseService.updateUrl(url.id, { enabled: true });

      activeUrls = await databaseService.getActiveUrls();
      expect(activeUrls).toHaveLength(1);
    });
  });

  describe('Performance under realistic load', () => {
    test('should handle realistic monitoring load', async () => {
      const userCount = 10;
      const urlsPerUser = 3;
      const totalUrls = userCount * urlsPerUser;

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨URLä½œæˆ
      const users = [];
      const urls = [];

      for (let i = 1; i <= userCount; i++) {
        const user = await databaseService.createUser({
          id: `user_${i}`,
          username: `user${i}`,
          chatId: `chat_${i}`,
          urlLimit: urlsPerUser
        });
        users.push(user);

        for (let j = 1; j <= urlsPerUser; j++) {
          const url = await databaseService.createUrl({
            url: `https://suumo.jp/user${i}_property${j}`,
            name: `ãƒ¦ãƒ¼ã‚¶ãƒ¼${i}ç‰©ä»¶${j}`,
            userId: user.id,
            interval: 300
          });
          urls.push(url);

          // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒƒã‚¯
          nock('https://suumo.jp')
            .get(`/user${i}_property${j}`)
            .reply(200, `
              <html>
                <body>
                  ${Array.from({length: j}, (_, k) => `<div class="cassetteitem">ç‰©ä»¶${i}-${j}-${k+1}</div>`).join('')}
                </body>
              </html>
            `);
        }
      }

      // å…¨URLä¸¦è¡Œç›£è¦–
      const startTime = Date.now();
      const results = await Promise.all(
        urls.map(url => monitoringService.checkUrl(url.id))
      );
      const totalTime = Date.now() - startTime;

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼
      expect(results).toHaveLength(totalUrls);
      expect(totalTime).toBeLessThan(30000); // 30ç§’ä»¥å†…

      // å…¨ã¦æˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      results.forEach(result => {
        expect(result.hasNew).toBe(true);
        expect(result.method).toBe('http-only');
      });

      // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç¢ºèª
      const memoryUsage = process.memoryUsage();
      expect(memoryUsage.heapUsed / 1024 / 1024).toBeLessThan(100); // 100MBä»¥ä¸‹
    });
  });
});
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# E2Eãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pnpm test:e2e

# ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå»¶é•·
pnpm test:e2e --testTimeout=60000

# E2Eãƒ†ã‚¹ãƒˆ + è©³ç´°ãƒ­ã‚°
pnpm test:e2e --verbose
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

### è² è·ãƒ†ã‚¹ãƒˆ

#### ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒ†ã‚¹ãƒˆ

```javascript
// tests/performance/memory.test.js
const ScrapingService = require('../../src/services/scraping');
const DatabaseService = require('../../src/services/database');

describe('Memory Performance Tests', () => {
  let scrapingService;
  let databaseService;

  beforeAll(() => {
    scrapingService = new ScrapingService();
    databaseService = new DatabaseService(':memory:');
  });

  test('should maintain memory usage under 60MB during scraping', async () => {
    const initialMemory = process.memoryUsage().heapUsed;

    // å¤§é‡ã®ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å®Ÿè¡Œ
    const promises = [];
    for (let i = 0; i < 50; i++) {
      promises.push(
        scrapingService.checkNewListings(`https://example.com/page${i}`)
      );
    }

    await Promise.allSettled(promises);

    // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å¼·åˆ¶å®Ÿè¡Œ
    if (global.gc) {
      global.gc();
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;

    expect(memoryIncrease).toBeLessThan(30); // 30MBä»¥ä¸‹ã®å¢—åŠ 
    expect(finalMemory / 1024 / 1024).toBeLessThan(60); // ç·ä½¿ç”¨é‡60MBä»¥ä¸‹
  });

  test('should handle memory pressure gracefully', async () => {
    // ãƒ¡ãƒ¢ãƒªåˆ¶é™ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    const originalMaxOldSpaceSize = process.env.NODE_OPTIONS;
    process.env.NODE_OPTIONS = '--max-old-space-size=128'; // 128MBåˆ¶é™

    try {
      // ãƒ¡ãƒ¢ãƒªé›†ç´„çš„ãªå‡¦ç†
      const largeData = [];
      for (let i = 0; i < 100; i++) {
        largeData.push(await scrapingService.checkNewListings('https://example.com/large'));
      }

      // ãƒ¡ãƒ¢ãƒªä¸è¶³ã§ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ãªã„ã“ã¨ã‚’ç¢ºèª
      expect(largeData).toHaveLength(100);
    } finally {
      process.env.NODE_OPTIONS = originalMaxOldSpaceSize;
    }
  });
});
```

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒ†ã‚¹ãƒˆ

```javascript
// tests/performance/response-time.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Response Time Performance Tests', () => {
  test('should respond to health check within 100ms', async () => {
    const startTime = Date.now();

    await request(app)
      .get('/health')
      .expect(200);

    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(100);
  });

  test('should handle concurrent requests efficiently', async () => {
    const concurrentRequests = 20;
    const startTime = Date.now();

    const promises = Array.from({ length: concurrentRequests }, () =>
      request(app).get('/health').expect(200)
    );

    await Promise.all(promises);

    const totalTime = Date.now() - startTime;
    const avgResponseTime = totalTime / concurrentRequests;

    expect(avgResponseTime).toBeLessThan(200); // å¹³å‡200msä»¥ä¸‹
  });
});
```

### ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ

```javascript
// tests/performance/stress.test.js
const MonitoringService = require('../../src/services/monitoring');
const DatabaseService = require('../../src/services/database');

describe('Stress Tests', () => {
  let monitoringService;
  let databaseService;

  beforeAll(async () => {
    databaseService = new DatabaseService(':memory:');
    await databaseService.initialize();
    monitoringService = new MonitoringService(databaseService);
  });

  test('should handle high-frequency monitoring', async () => {
    const urlCount = 100;
    const checkInterval = 100; // 100msé–“éš”

    // å¤§é‡ã®URLä½œæˆ
    const urls = [];
    for (let i = 0; i < urlCount; i++) {
      const url = await databaseService.createUrl({
        url: `https://example.com/stress${i}`,
        name: `ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ${i}`,
        userId: 'stress_user',
        interval: checkInterval
      });
      urls.push(url);
    }

    // é«˜é »åº¦ç›£è¦–å®Ÿè¡Œ
    const startTime = Date.now();
    const duration = 10000; // 10ç§’é–“

    const results = [];
    while (Date.now() - startTime < duration) {
      const promises = urls.map(url => 
        monitoringService.checkUrl(url.id).catch(error => ({ error }))
      );
      
      const batchResults = await Promise.allSettled(promises);
      results.push(...batchResults);

      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }

    // çµæœæ¤œè¨¼
    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const successRate = successCount / results.length;

    expect(successRate).toBeGreaterThan(0.95); // 95%ä»¥ä¸Šã®æˆåŠŸç‡
  });
});
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

### å…¥åŠ›å€¤æ¤œè¨¼ãƒ†ã‚¹ãƒˆ

```javascript
// tests/security/input-validation.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Input Validation Security Tests', () => {
  describe('URL validation', () => {
    test('should reject malicious URLs', async () => {
      const maliciousUrls = [
        'javascript:alert("xss")',
        'data:text/html,<script>alert("xss")</script>',
        'file:///etc/passwd',
        'ftp://malicious.com/payload',
        'http://localhost:22/ssh-attack'
      ];

      for (const url of maliciousUrls) {
        const response = await request(app)
          .post('/api/urls')
          .send({
            url,
            name: 'ãƒ†ã‚¹ãƒˆ',
            userId: 'test_user'
          })
          .expect(400);

        expect(response.body.error).toContain('Invalid URL');
      }
    });

    test('should accept valid URLs only', async () => {
      const validUrls = [
        'https://suumo.jp/chintai/tokyo/',
        'https://www.homes.co.jp/chintai/',
        'https://athome.co.jp/chintai/'
      ];

      for (const url of validUrls) {
        await request(app)
          .post('/api/urls')
          .send({
            url,
            name: 'ãƒ†ã‚¹ãƒˆ',
            userId: 'test_user'
          })
          .expect(201);
      }
    });
  });

  describe('SQL injection prevention', () => {
    test('should prevent SQL injection in URL parameters', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE urls; --",
        "' OR '1'='1",
        "'; INSERT INTO urls VALUES ('malicious'); --"
      ];

      for (const payload of sqlInjectionPayloads) {
        const response = await request(app)
          .get(`/api/urls/${payload}`)
          .expect(400);

        expect(response.body.error).toContain('Invalid');
      }
    });
  });

  describe('XSS prevention', () => {
    test('should sanitize user input', async () => {
      const xssPayloads = [
        '<script>alert("xss")</script>',
        '"><script>alert("xss")</script>',
        'javascript:alert("xss")',
        '<img src="x" onerror="alert(\'xss\')">'
      ];

      for (const payload of xssPayloads) {
        const response = await request(app)
          .post('/api/urls')
          .send({
            url: 'https://suumo.jp/test',
            name: payload,
            userId: 'test_user'
          })
          .expect(201);

        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¿ã‚°ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
        expect(response.body.name).not.toContain('<script>');
        expect(response.body.name).not.toContain('javascript:');
      }
    });
  });
});
```

### èªè¨¼ãƒ»èªå¯ãƒ†ã‚¹ãƒˆ

```javascript
// tests/security/auth.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Authentication & Authorization Tests', () => {
  describe('API access control', () => {
    test('should require authentication for protected endpoints', async () => {
      const protectedEndpoints = [
        { method: 'post', path: '/api/urls' },
        { method: 'put', path: '/api/urls/test-id' },
        { method: 'delete', path: '/api/urls/test-id' },
        { method: 'get', path: '/api/monitoring/test-id/logs' }
      ];

      for (const endpoint of protectedEndpoints) {
        const response = await request(app)
          [endpoint.method](endpoint.path)
          .expect(401);

        expect(response.body.error).toContain('Unauthorized');
      }
    });

    test('should accept valid authentication', async () => {
      const validToken = 'valid_test_token';

      const response = await request(app)
        .post('/api/urls')
        .set('Authorization', `Bearer ${validToken}`)
        .send({
          url: 'https://suumo.jp/test',
          name: 'ãƒ†ã‚¹ãƒˆ',
          userId: 'test_user'
        })
        .expect(201);

      expect(response.body).toHaveProperty('id');
    });
  });

  describe('Rate limiting', () => {
    test('should enforce rate limits', async () => {
      const requests = [];

      // åˆ¶é™ã‚’è¶…ãˆã‚‹ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
      for (let i = 0; i < 150; i++) {
        requests.push(
          request(app)
            .get('/health')
            .expect(res => {
              expect([200, 429]).toContain(res.status);
            })
        );
      }

      const responses = await Promise.allSettled(requests);
      const rateLimitedCount = responses.filter(
        r => r.value && r.value.status === 429
      ).length;

      expect(rateLimitedCount).toBeGreaterThan(0);
    });
  });
});
```

## ãƒ†ã‚¹ãƒˆç’°å¢ƒæ§‹ç¯‰

### ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š

```javascript
// tests/setup.js
const DatabaseService = require('../src/services/database');
const path = require('path');
const fs = require('fs');

// ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
const TEST_DB_PATH = path.join(__dirname, 'fixtures/test.db');

beforeAll(async () => {
  // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
  const testDir = path.dirname(TEST_DB_PATH);
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }

  // ç’°å¢ƒå¤‰æ•°è¨­å®š
  process.env.NODE_ENV = 'test';
  process.env.DATABASE_PATH = TEST_DB_PATH;
  process.env.LOG_LEVEL = 'error';
  process.env.MOCK_TELEGRAM = 'true';
  process.env.MOCK_SCRAPING = 'true';
});

afterAll(async () => {
  // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å‰Šé™¤
  if (fs.existsSync(TEST_DB_PATH)) {
    fs.unlinkSync(TEST_DB_PATH);
  }
});

// ãƒ†ã‚¹ãƒˆç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
global.createTestUser = async (databaseService, overrides = {}) => {
  return await databaseService.createUser({
    id: 'test_user_1',
    username: 'testuser',
    firstName: 'ãƒ†ã‚¹ãƒˆ',
    lastName: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    languageCode: 'ja',
    urlLimit: 3,
    ...overrides
  });
};

global.createTestUrl = async (databaseService, overrides = {}) => {
  return await databaseService.createUrl({
    url: 'https://suumo.jp/test',
    name: 'ãƒ†ã‚¹ãƒˆç‰©ä»¶',
    userId: 'test_user_1',
    interval: 300,
    enabled: true,
    ...overrides
  });
};

// ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
global.measureMemory = (fn) => {
  return async (...args) => {
    const initialMemory = process.memoryUsage().heapUsed;
    const result = await fn(...args);
    const finalMemory = process.memoryUsage().heapUsed;
    
    return {
      result,
      memoryUsed: (finalMemory - initialMemory) / 1024 / 1024 // MB
    };
  };
};
```

### ãƒ¢ãƒƒã‚¯è¨­å®š

```javascript
// tests/mocks/telegram.js
class MockTelegramService {
  constructor() {
    this.sentMessages = [];
    this.commands = [];
  }

  async sendMessage(chatId, text, options = {}) {
    this.sentMessages.push({ chatId, text, options });
    return {
      success: true,
      messageId: Math.floor(Math.random() * 1000000)
    };
  }

  async processCommand(message) {
    this.commands.push(message);
    return {
      command: message.text.split(' ')[0].substring(1),
      success: true
    };
  }

  getLastMessage() {
    return this.sentMessages[this.sentMessages.length - 1];
  }

  getMessageCount() {
    return this.sentMessages.length;
  }

  clearHistory() {
    this.sentMessages = [];
    this.commands = [];
  }
}

module.exports = MockTelegramService;
```

```javascript
// tests/mocks/scraping.js
class MockScrapingService {
  constructor() {
    this.responses = new Map();
    this.defaultResponse = {
      hasNew: true,
      newCount: 3,
      method: 'http-only',
      responseTime: 1500,
      memoryUsage: 25.5,
      botProtection: false
    };
  }

  setResponse(url, response) {
    this.responses.set(url, response);
  }

  async checkNewListings(url, options = {}) {
    const response = this.responses.get(url) || this.defaultResponse;
    
    // Botå¯¾ç­–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    if (options.botProtection) {
      return {
        ...response,
        method: 'google-bypass',
        botProtection: true,
        responseTime: response.responseTime + 2000
      };
    }

    return response;
  }

  clearResponses() {
    this.responses.clear();
  }
}

module.exports = MockScrapingService;
```

## CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### GitHub Actionsè¨­å®š

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop, lightweight-version ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'pnpm'

    - name: Install pnpm
      run: npm install -g pnpm

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run linting
      run: pnpm lint

    - name: Run unit tests
      run: pnpm test:unit --coverage

    - name: Run integration tests
      run: pnpm test:integration

    - name: Run E2E tests
      run: pnpm test:e2e
      timeout-minutes: 10

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

    - name: Performance benchmark
      run: pnpm test:performance

  security:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Run security audit
      run: |
        npm audit --audit-level moderate
        pnpm audit --audit-level moderate

    - name: Run security tests
      run: pnpm test:security
```

### ãƒ†ã‚¹ãƒˆå“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹

#### ã‚«ãƒãƒ¬ãƒƒã‚¸è¨­å®š

```javascript
// jest.config.js
module.exports = {
  // ... ä»–ã®è¨­å®š

  collectCoverageFrom: [
    'src/**/*.js',
    '!src/main.js',
    '!src/**/*.test.js',
    '!src/**/*.spec.js',
    '!src/config/**',
    '!src/migrations/**'
  ],

  coverageThreshold: {
    global: {
      branches: 85,
      functions: 85,
      lines: 85,
      statements: 85
    },
    './src/services/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },

  coverageReporters: [
    'text',
    'text-summary',
    'lcov',
    'html',
    'json'
  ]
};
```

#### å“è³ªã‚²ãƒ¼ãƒˆ

```bash
# scripts/quality-gate.sh
#!/bin/bash

echo "ğŸ” è»½é‡ã‚½ã‚¯ãƒ–ãƒ„å“è³ªã‚²ãƒ¼ãƒˆå®Ÿè¡Œä¸­..."

# 1. ãƒªãƒ³ãƒˆæ¤œæŸ»
echo "1. ãƒªãƒ³ãƒˆæ¤œæŸ»"
pnpm lint
if [ $? -ne 0 ]; then
  echo "âŒ ãƒªãƒ³ãƒˆæ¤œæŸ»å¤±æ•—"
  exit 1
fi

# 2. å˜ä½“ãƒ†ã‚¹ãƒˆ + ã‚«ãƒãƒ¬ãƒƒã‚¸
echo "2. å˜ä½“ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
pnpm test:unit --coverage --silent
if [ $? -ne 0 ]; then
  echo "âŒ å˜ä½“ãƒ†ã‚¹ãƒˆå¤±æ•—"
  exit 1
fi

# 3. ã‚«ãƒãƒ¬ãƒƒã‚¸é–¾å€¤ç¢ºèª
COVERAGE=$(grep -o '"pct":[0-9.]*' coverage/coverage-summary.json | head -1 | cut -d':' -f2)
if (( $(echo "$COVERAGE < 85" | bc -l) )); then
  echo "âŒ ã‚«ãƒãƒ¬ãƒƒã‚¸ä¸è¶³: ${COVERAGE}% (æœ€ä½85%å¿…è¦)"
  exit 1
fi

# 4. çµ±åˆãƒ†ã‚¹ãƒˆ
echo "3. çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
pnpm test:integration --silent
if [ $? -ne 0 ]; then
  echo "âŒ çµ±åˆãƒ†ã‚¹ãƒˆå¤±æ•—"
  exit 1
fi

# 5. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
echo "4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
pnpm test:security --silent
if [ $? -ne 0 ]; then
  echo "âŒ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå¤±æ•—"
  exit 1
fi

# 6. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
echo "5. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
pnpm test:performance --silent
if [ $? -ne 0 ]; then
  echo "âŒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—"
  exit 1
fi

echo "âœ… å…¨ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ"
echo "ğŸ“Š ã‚«ãƒãƒ¬ãƒƒã‚¸: ${COVERAGE}%"
echo "ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™å®Œäº†"
```

## ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç†

### ãƒ•ã‚£ã‚¯ã‚¹ãƒãƒ£ç®¡ç†

```javascript
// tests/fixtures/users.js
module.exports = {
  validUser: {
    id: 'test_user_1',
    username: 'testuser',
    firstName: 'ãƒ†ã‚¹ãƒˆ',
    lastName: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    languageCode: 'ja',
    isActive: true,
    urlLimit: 3
  },

  premiumUser: {
    id: 'premium_user_1',
    username: 'premiumuser',
    firstName: 'ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ',
    lastName: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    languageCode: 'ja',
    isActive: true,
    urlLimit: 10
  },

  inactiveUser: {
    id: 'inactive_user_1',
    username: 'inactiveuser',
    firstName: 'ç„¡åŠ¹',
    lastName: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    languageCode: 'ja',
    isActive: false,
    urlLimit: 3
  }
};
```

```javascript
// tests/fixtures/urls.js
module.exports = {
  suumoUrl: {
    url: 'https://suumo.jp/jj/chintai/ichiran/FR301FC001/?ar=030&bs=040',
    name: 'æ¸‹è°·ã‚¨ãƒªã‚¢ãƒ»1K',
    interval: 300,
    enabled: true
  },

  homesUrl: {
    url: 'https://www.homes.co.jp/chintai/tokyo/shibuya-city/',
    name: 'HOMESæ¸‹è°·',
    interval: 600,
    enabled: true
  },

  disabledUrl: {
    url: 'https://suumo.jp/disabled',
    name: 'ç„¡åŠ¹URL',
    interval: 300,
    enabled: false
  }
};
```

### ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ

```javascript
// tests/utils/data-generator.js
const { v4: uuidv4 } = require('uuid');

class TestDataGenerator {
  static generateUser(overrides = {}) {
    return {
      id: uuidv4(),
      username: `user_${Math.random().toString(36).substr(2, 9)}`,
      firstName: 'ãƒ†ã‚¹ãƒˆ',
      lastName: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
      languageCode: 'ja',
      isActive: true,
      urlLimit: 3,
      ...overrides
    };
  }

  static generateUrl(userId, overrides = {}) {
    const domains = ['suumo.jp', 'homes.co.jp', 'athome.co.jp'];
    const areas = ['shibuya', 'shinjuku', 'ikebukuro', 'ginza'];
    const types = ['1k', '1dk', '1ldk', '2k'];

    const domain = domains[Math.floor(Math.random() * domains.length)];
    const area = areas[Math.floor(Math.random() * areas.length)];
    const type = types[Math.floor(Math.random() * types.length)];

    return {
      id: uuidv4(),
      url: `https://${domain}/chintai/${area}/${type}/`,
      name: `${area}ã‚¨ãƒªã‚¢ãƒ»${type.toUpperCase()}`,
      userId,
      interval: 300 + Math.floor(Math.random() * 600),
      enabled: Math.random() > 0.2, // 80%ã®ç¢ºç‡ã§æœ‰åŠ¹
      ...overrides
    };
  }

  static generateMonitoringLog(urlId, overrides = {}) {
    const methods = ['http-only', 'jsdom', 'google-bypass'];
    const method = methods[Math.floor(Math.random() * methods.length)];

    return {
      id: uuidv4(),
      urlId,
      newCount: Math.floor(Math.random() * 10),
      hasNew: Math.random() > 0.4, // 60%ã®ç¢ºç‡ã§æ–°ç€ã‚ã‚Š
      method,
      responseTime: 500 + Math.floor(Math.random() * 2000),
      memoryUsage: 20 + Math.random() * 30,
      botProtection: method === 'google-bypass',
      checkedAt: new Date(),
      ...overrides
    };
  }

  static async seedDatabase(databaseService, options = {}) {
    const {
      userCount = 5,
      urlsPerUser = 3,
      logsPerUrl = 10
    } = options;

    const users = [];
    const urls = [];

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
    for (let i = 0; i < userCount; i++) {
      const user = await databaseService.createUser(
        this.generateUser({ username: `testuser${i + 1}` })
      );
      users.push(user);

      // URLä½œæˆ
      for (let j = 0; j < urlsPerUser; j++) {
        const url = await databaseService.createUrl(
          this.generateUrl(user.id)
        );
        urls.push(url);

        // ç›£è¦–ãƒ­ã‚°ä½œæˆ
        for (let k = 0; k < logsPerUrl; k++) {
          await databaseService.saveMonitoringLog(
            this.generateMonitoringLog(url.id)
          );
        }
      }
    }

    return { users, urls };
  }
}

module.exports = TestDataGenerator;
```

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰å“è³ª

#### 1. å¯èª­æ€§é‡è¦–

```javascript
// âŒ æ‚ªã„ä¾‹
test('test1', async () => {
  const r = await s.check('https://suumo.jp/test');
  expect(r.h).toBe(true);
  expect(r.n).toBe(3);
});

// âœ… è‰¯ã„ä¾‹
test('should detect new listings when 3 properties are found', async () => {
  // Arrange
  const testUrl = 'https://suumo.jp/test-property-page';
  const expectedNewCount = 3;

  // Act
  const result = await scrapingService.checkNewListings(testUrl);

  // Assert
  expect(result.hasNew).toBe(true);
  expect(result.newCount).toBe(expectedNewCount);
  expect(result.method).toBe('http-only');
});
```

#### 2. ç‹¬ç«‹æ€§ç¢ºä¿

```javascript
// âœ… å„ãƒ†ã‚¹ãƒˆãŒç‹¬ç«‹ã—ã¦ã„ã‚‹
describe('URL management', () => {
  beforeEach(async () => {
    // å„ãƒ†ã‚¹ãƒˆå‰ã«ã‚¯ãƒªãƒ¼ãƒ³ãªçŠ¶æ…‹ã‚’ä½œæˆ
    await databaseService.clearAllData();
    await createTestUser(databaseService);
  });

  test('should create URL successfully', async () => {
    // ã“ã®ãƒ†ã‚¹ãƒˆã¯ä»–ã®ãƒ†ã‚¹ãƒˆã®å½±éŸ¿ã‚’å—ã‘ãªã„
  });

  test('should update URL successfully', async () => {
    // ã“ã®ãƒ†ã‚¹ãƒˆã‚‚ç‹¬ç«‹ã—ã¦ã„ã‚‹
  });
});
```

#### 3. é©åˆ‡ãªãƒ¢ãƒƒã‚¯ä½¿ç”¨

```javascript
// âœ… å¤–éƒ¨ä¾å­˜ã‚’ãƒ¢ãƒƒã‚¯åŒ–
test('should handle network timeout gracefully', async () => {
  // å¤–éƒ¨APIã‚’ãƒ¢ãƒƒã‚¯åŒ–
  nock('https://suumo.jp')
    .get('/test-url')
    .socketDelay(30000) // 30ç§’é…å»¶
    .reply(200, 'response');

  const result = await scrapingService.checkNewListings(
    'https://suumo.jp/test-url',
    { timeout: 5000 }
  );

  expect(result.error).toContain('timeout');
});
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### 1. ä¸¦åˆ—å®Ÿè¡Œ

```javascript
// âœ… ç‹¬ç«‹ã—ãŸãƒ†ã‚¹ãƒˆã¯ä¸¦åˆ—å®Ÿè¡Œ
describe('Multiple URL processing', () => {
  test('should process multiple URLs concurrently', async () => {
    const urls = [
      'https://suumo.jp/url1',
      'https://suumo.jp/url2',
      'https://suumo.jp/url3'
    ];

    // ä¸¦åˆ—å®Ÿè¡Œã§ãƒ†ã‚¹ãƒˆæ™‚é–“çŸ­ç¸®
    const results = await Promise.all(
      urls.map(url => scrapingService.checkNewListings(url))
    );

    expect(results).toHaveLength(3);
    results.forEach(result => {
      expect(result).toHaveProperty('hasNew');
    });
  });
});
```

#### 2. ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–

```javascript
// âœ… å¿…è¦æœ€å°é™ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
test('should calculate statistics correctly', async () => {
  const urlId = 'test_url_1';

  // æœ€å°é™ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§çµ±è¨ˆè¨ˆç®—ã‚’ãƒ†ã‚¹ãƒˆ
  const testLogs = [
    { newCount: 0, hasNew: false, responseTime: 1000 },
    { newCount: 3, hasNew: true, responseTime: 1500 },
    { newCount: 1, hasNew: true, responseTime: 800 }
  ];

  for (const log of testLogs) {
    await databaseService.saveMonitoringLog({ urlId, ...log });
  }

  const stats = await databaseService.getMonitoringStats(urlId);
  
  expect(stats.totalChecks).toBe(3);
  expect(stats.newDetections).toBe(2);
  expect(stats.avgResponseTime).toBe(1100);
});
```

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

#### 1. æœŸå¾…ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã®ãƒ†ã‚¹ãƒˆ

```javascript
// âœ… ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚‚é©åˆ‡ã«ãƒ†ã‚¹ãƒˆ
test('should throw error for invalid URL format', async () => {
  const invalidUrl = 'not-a-valid-url';

  await expect(
    scrapingService.checkNewListings(invalidUrl)
  ).rejects.toThrow('Invalid URL format');
});

test('should handle network errors gracefully', async () => {
  nock('https://suumo.jp')
    .get('/network-error')
    .replyWithError('ECONNREFUSED');

  const result = await scrapingService.checkNewListings(
    'https://suumo.jp/network-error'
  );

  expect(result.hasNew).toBe(false);
  expect(result.error).toContain('ECONNREFUSED');
});
```

#### 2. å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆ

```javascript
// âœ… å¢ƒç•Œå€¤ã§ã®å‹•ä½œç¢ºèª
describe('URL limit enforcement', () => {
  test('should allow creation up to limit', async () => {
    const userId = 'test_user_1';
    const urlLimit = 3;

    await databaseService.createUser({
      id: userId,
      username: 'testuser',
      urlLimit
    });

    // åˆ¶é™å€¤ã¾ã§ä½œæˆï¼ˆæˆåŠŸï¼‰
    for (let i = 0; i < urlLimit; i++) {
      await expect(
        databaseService.createUrl({
          url: `https://suumo.jp/test${i}`,
          name: `ãƒ†ã‚¹ãƒˆ${i}`,
          userId
        })
      ).resolves.toHaveProperty('id');
    }

    // åˆ¶é™å€¤ã‚’è¶…ãˆã‚‹ä½œæˆï¼ˆå¤±æ•—ï¼‰
    await expect(
      databaseService.createUrl({
        url: 'https://suumo.jp/over-limit',
        name: 'åˆ¶é™è¶…é',
        userId
      })
    ).rejects.toThrow('URL limit exceeded');
  });
});
```

## ã¾ã¨ã‚

è»½é‡ã‚½ã‚¯ãƒ–ãƒ„ã®ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¯ã€è‡ªå®…ã‚µãƒ¼ãƒãƒ¼ç’°å¢ƒã§ã®ç‰©ä»¶ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã«ç‰¹åŒ–ã—ãŸåŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚

### ä¸»è¦ãªç‰¹å¾´

1. **è»½é‡æ€§é‡è¦–**: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡100MBä»¥ä¸‹ã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
2. **å®Ÿç”¨æ€§é‡è¦–**: å®Ÿéš›ã®ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ããƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
3. **è‡ªå‹•åŒ–é‡è¦–**: CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ã®å®Œå…¨çµ±åˆ
4. **å“è³ªä¿è¨¼**: 85%ä»¥ä¸Šã®ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸ç¶­æŒ

### æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

- **å“è³ªå‘ä¸Š**: åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹é«˜å“è³ªãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢
- **é–‹ç™ºåŠ¹ç‡**: è‡ªå‹•åŒ–ã•ã‚ŒãŸãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹è¿…é€Ÿãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
- **ä¿å®ˆæ€§**: æ§‹é€ åŒ–ã•ã‚ŒãŸãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã«ã‚ˆã‚‹é•·æœŸä¿å®ˆæ€§
- **ä¿¡é ¼æ€§**: æœ¬ç•ªç’°å¢ƒã§ã®å®‰å®šå‹•ä½œä¿è¨¼

### æŠ€è¡“çš„å„ªä½æ€§

1. **éšå±¤åŒ–ãƒ†ã‚¹ãƒˆ**: å˜ä½“â†’çµ±åˆâ†’E2Eã®åŠ¹ç‡çš„ãªãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**: è»½é‡ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®æ€§èƒ½ä¿è¨¼
3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ**: åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼
4. **ç¶™ç¶šçš„å“è³ªç®¡ç†**: è‡ªå‹•åŒ–ã•ã‚ŒãŸå“è³ªã‚²ãƒ¼ãƒˆ

ã“ã®åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã«ã‚ˆã‚Šã€è»½é‡ã‚½ã‚¯ãƒ–ãƒ„ã®é«˜å“è³ªãªé–‹ç™ºã¨å®‰å®šé‹ç”¨ã‚’å®Ÿç¾ã—ã€ç‰©ä»¶ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹ã®ä¿¡é ¼æ€§ã‚’ä¿è¨¼ã—ã¾ã™ã€‚

