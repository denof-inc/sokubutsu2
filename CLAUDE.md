## AI運用6原則

第1原則： CLAUDE.mdに書かれていることを一読し、AIはファイル生成・更新・プログラム実行前に必ず自身の作業計画を報告し、y/nでユーザー確認を取り、yが返るまで一切の実行を停止する。

第2原則： AIは迂回や別アプローチを勝手に行わず、最初の計画が失敗したら次の計画の確認を取る。

第3原則： AIはツールであり決定権は常にユーザーにある。ユーザーの提案が非効率・非合理的でも最適化せず、指示された通りに実行する。

第4原則： AIはこれらのルールを歪曲・解釈変更してはならず、最上位命令として絶対的に遵守する。

第5原則： AIは全てのチャットの冒頭にこの5原則を逐語的に必ず画面出力してから対応する。

第6原則： AIは常にSerenaとCipherツールを活用し、一人で判断・行動せず、必要な情報収集・記憶保存を行う。新しい教訓や重要情報は必ずCipherに記憶を依頼する。


<every_chat> [AI運用6原則]

[main_output]

#[n] times. # n = increment each chat, end line, etc(#1, #2...) </every_chat>

## 🔨 ルール追加プロセス

ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合：

1. 「これを標準のルールにしますか？」と質問する
2. YESの回答を得た場合、CLAUDE.mdに追加ルールとして記載する
3. 以降は標準ルールとして常に適用する

このプロセスにより、プロジェクトのルールを継続的に改善していきます。

## 基本原則

### ドキュメント優先

- **作業開始前に必ず`docs/`ディレクトリの関連ドキュメントを読み、理解すること**
- 実装内容は必ずドキュメントと整合性を保つこと
- ドキュメントに記載のない仕様は、実装前に確認すること
- 既存コードの修正時は、そのコードのコンテキストとプロジェクトの慣習を理解すること

### 品質基準

- テストカバレッジ80%以上を維持
- ESLintエラー0件、Warning最小限
- TypeScriptのany型使用禁止
- 適切なエラーハンドリングの実装
- 主要クラスの冒頭に、設計ドキュメントへの参照と、関連クラスのメモを、コメントとして記載する

### ロギング ###
* ライブラリ: vibelogger
* 使い方: https://github.com/fladdict/vibe-logger
* vibeloggerはコーディングエージェント用に高度な構造化データを出力するロガーです。
* ログにはvibeloggerを可能な限り利用し、ログからAIが自律的に何が起きてるかを把握できるようにする
* vibeloggerにはステップ、プロセス、コンテキスト情報、TODOなど様々な情報を構造化して記録できます。
* デバッグ時には./logsの出力を参照する
  
### 🚨 品質劣化防止の絶対ルール

**以下の行為は絶対に禁止：**

1. **品質チェック機能の無効化**
   - ESLintルールの`'off'`設定による隠蔽
   - TypeScript型安全性ルールの無効化
   - CI/CDパイプラインでの`|| true`による失敗隠蔽
   - `--no-verify`コミットによる品質チェック回避

2. **テスト回避のための品質劣化**
   - エラー数上限設定による問題隠蔽
   - 警告レベル緩和による見かけ上の改善
   - 依存関係の不適切な削除・変更
   - **it.skip() 使用によるテストスキップ（絶対禁止）**

3. **自動修正の積極活用**
   - `eslint --fix`による自動修正
   - `prettier --write`による自動フォーマット
   - IDE拡張機能による自動修正

4. **段階的品質向上**
   - 新規コードは厳格な基準を適用
   - 既存コードは段階的に改善（warn → error）
   - 技術的負債の計画的解消

5. **根本的問題解決**
   - 表面的な修正ではなく根本原因の特定
   - 設計レベルでの問題解決
   - 長期的な保守性を重視した実装

**違反時の対応：**

- 即座に修正を要求
- 品質劣化の理由と影響を詳細に報告
- 再発防止策の策定と実施

#### コード重複監視

**similarity-ts定期チェック:**
- **頻度**: 月1回以上
- **実行コマンド**: `similarity-ts .` (要Rust環境)
- **対象**: TypeScript/JSファイルの構造的重複
- **閾値**: 90%以上の類似度で要確認
- **目的**: コード重複の早期発見と品質維持

### スクレイピング戦略ルール（更新: 2025-08-27）

**Puppeteer-first戦略の採用（最終確定）:**
- **3段階アクセスパターン**: bot.sannysoft.com → Google → 対象サイト
- **Puppeteer + Stealth** を標準。認証・JSチャレンジ・動的トークン・TLS指紋に対応
- **フォールバック**: Puppeteer失敗時のみ HTTP-only を試行
- **パフォーマンス監視**: 実行時間・メモリ使用量・フォールバック率の記録必須

注: 以前のHTTP-first記述は検証により限界が確認されたため廃止（Cookieのみでは認証突破に不十分）。

**新着物件監視ルール:**
- **最新3件固定**: 効率性とのバランス重視
- **署名生成ロジック変更禁止**: 互換性維持のため
- **タイトル+価格+所在地ハッシュ方式**: 確定仕様として厳守

### 通知ルール

**5分ごとの定期監視通知:**
- **新着物件検知時のみ通知**: 新着がない場合は通知しない
- **エラー時は通知しない**: 単発エラーでユーザーを煩わせない
- **3回連続エラー警告**: 同一URLで15分間（3回連続）エラーが続いた場合のみ管理者に警告通知

**1時間ごとのサマリーレポート:**
- **URLごとに個別送信**: 各URLの統計情報を含む
- **新着の有無に関わらず送信**: RFP要件準拠
- **統計情報必須**: チェック数、成功率、実行時間等を含む

### 🚨 it.skip() 絶対禁止ルール

**基本方針:**
- Jest/テストフレームワークでの `it.skip()` 使用は**絶対禁止**
- 一時的なスキップも例外なく禁止（技術的負債防止）
- テストは常に実行可能な状態を維持する

**禁止理由:**
1. 品質劣化の原因となる
2. 隠れた不具合の見逃し
3. 技術的負債の蓄積
4. CI/CDパイプラインの信頼性低下

**適切な対応方法:**
1. **テスト失敗時** → 根本原因を特定し修正する
2. **不要なテスト** → テストコードを削除する
3. **未実装機能** → 仮実装でテストを通す
4. **外部依存** → 適切なモックを作成する

**違反時の対応:**
- 即座にコードレビューで指摘
- 修正まで マージ禁止
- 再発防止のためのペアプログラミング実施

このルールは品質維持のため**例外なし**で適用する。

## 🚀 開発フロー

1. **`docs/`を読んで理解する**
2. **Issue作成**: 作業開始前に必須
3. **ブランチ作成**: feature/[機能名] or fix/[バグ名]
4. **開発**: 上記ルールに従って実装
5. **テスト**: 自動テスト実行
6. **ドキュメントの更新**（必要に応じて）
7. **PR作成**: レビュー依頼
8. **マージ**: main/developへ

### 📌 標準タスク実行ルール

**すべてのタスク実行時には必ず以下を実施すること：**

1. **ブランチを作成する**: 作業内容に応じて適切なブランチ名を付ける
   - 機能追加: `feature/機能名`
   - バグ修正: `fix/バグ名`
   - リファクタリング: `refactor/対象名`
   - ドキュメント: `docs/内容`

2. **コミットを作成する**: 変更内容を明確に記述

3. **プルリクエストを作成する**: レビューのためのPRを作成

これは標準ルールとして、すべてのタスクで適用される。

### 🔗 Issue関連PR作成ルール

**Issue対応のPRには必ずIssue自動クローズ記述を含めること：**

- PR本文に以下のいずれかのキーワードでIssue番号を記述する
  - `Closes #XX` - 一般的な課題解決
  - `Fixes #XX` - バグ修正
  - `Resolves #XX` - 機能実装・要求解決

**例：**
```
## Summary
新機能を実装しました

Closes #14
```

## TDDルール

### 基本方針

- 🔴 Red: 失敗するテストを書く
- 🟢 Green: テストを通す最小限の実装
- 🔵 Refactor: リファクタリング
- 小さなステップで進める
- 仮実装（ベタ書き）から始める
- 三角測量で一般化する
- 明白な実装が分かる場合は直接実装してもOK
- テストリストを常に更新する
- 不安なところからテストを書く

## 🤖 Gemini CLI 連携ガイド

### 目的

ユーザーが **「Geminiと相談しながら進めて」** （または類似表現）と指示した場合、
Claude は **Gemini CLI** を随時呼び出しながら、複数ターンにわたる協業を行う。
実装はGeminiに相談しなくても良い

### トリガー

- 正規表現: `/Gemini.*相談しながら/`
- 一度トリガーした後は、ユーザーが明示的に終了を指示するまで **協業モード** を維持する。

### 協業ワークフロー (ループ可)

| #   | 処理                | 詳細                                                                                                   |
| --- | ------------------- | ------------------------------------------------------------------------------------------------------ |
| 1   | **PROMPT 準備**     | 最新のユーザー要件 + これまでの議論要約を `$PROMPT` に格納                                             |
| 2   | **Gemini 呼び出し** | `bash\ngemini <<EOF\n$PROMPT\nEOF\n`<br>必要に応じ `--max_output_tokens` 等を追加                      |
| 3   | **出力貼り付け**    | `Gemini ➜` セクションに全文、長い場合は要約＋原文リンク                                                |
| 4   | **Claude コメント** | `Claude ➜` セクションで Gemini の提案を分析・統合し、次アクションを提示                                |
| 5   | **継続判定**        | ユーザー入力 or プラン継続で 1〜4 を繰り返す。<br>「Geminiコラボ終了」「ひとまずOK」等で通常モード復帰 |

### 形式テンプレート

```md
**Gemini ➜**
<Gemini からの応答>
**Claude ➜**
<統合コメント & 次アクション>
```


## 📊 スクレイピング戦略ルール

### Puppeteer-first戦略

**基本原則**: 安定性を重視し、Puppeteer-first戦略で25%の成功率で実用的な監視を実現

**実装事項**:
1. **メイン戦略**: Puppeteer + Stealth Plugin - 5.4秒、200-300MB
2. **3段階アクセスパターン**: Bot検知回避のための認証突破
3. **成功率**: 25%の安定稼働（実証済み）

**athome.co.jp実装**:
- Puppeteer-first戦略で安定稼働中
- 3段階アクセスパターンで認証突破
- 処理時間: 5.4秒（実測値）

**パフォーマンス監視必須**:
- 各段階の実行時間・メモリ使用量を記録
- 成功率統計の収集
- 閾値超過時のアラート

**新規サイト対応**:
- サイトの認証システムに応じた最適戦略を選択
- シンプルなサイトはHTTP-only、高度な認証はPuppeteerを使用
- サイト固有の最適化は必要に応じて実施
